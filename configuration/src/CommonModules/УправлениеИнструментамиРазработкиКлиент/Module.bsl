///////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2025, ООО ДНС Технологии
// SDMS (Software Development Management System) — это корпоративная система учета разработки и управления проектами 
// Все права защищены. Эта программа и сопроводительные материалы предоставляются 
// в соответствии с условиями лицензии General Public License (GNU GPL v3)
// Текст лицензии доступен по ссылке:
// https://www.gnu.org/licenses/gpl-3.0.html
///////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Клиентские процедуры и функции для управления инструментами разработки
//
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Обработчик нажатия на элементы внутри поля HTML-документа.
//
// Параметры:
//  ДанныеСобытяи        - ФиксированнаяСтруктура - свойства события. Дополнительно см.
//                         описания события ПриНажатии расширения поля формы для поля 
//                         HTML-документа в синтаксис-помощнике.
//  СтандартнаяОбработка - Булево -  признак выполнения стандартной (системной) обработки события.
//
Процедура ПриНажатииПоляHTMLДокумента(ДанныеСобытия, СтандартнаяОбработка) Экспорт
	
	СтандартнаяОбработка = Ложь;	
	НавигационнаяСсылка = ДанныеСобытия.Href;
	
	Если НЕ ПустаяСтрока(НавигационнаяСсылка) Тогда
		ПозицияСсылкиНаПользователя = СтрНайти(НавигационнаяСсылка, "user_");
		
		Если ПозицияСсылкиНаПользователя <> 0 Тогда 
			ИдентификаторПользователя = Новый УникальныйИдентификатор(Сред(НавигационнаяСсылка, ПозицияСсылкиНаПользователя + 5)); 
			ИнтерфейсПриложенияКлиент.ОткрытьИнформациюОПользователе(ЭтотОбъект, ИдентификаторПользователя, СтандартнаяОбработка);
				
		ИначеЕсли ОбщегоНазначенияКлиент.ЭтоВебСсылка(НавигационнаяСсылка)
			ИЛИ ОбщегоНазначенияКлиент.ЭтоНавигационнаяСсылка(НавигационнаяСсылка) Тогда 
			
			ПерейтиПоНавигационнойСсылке(НавигационнаяСсылка);
		КонецЕсли;
	КонецЕсли;
		
КонецПроцедуры

Процедура ОбработкаАктивизацииСтроки(Знач ТекущиеДанные, НастройкиСписка) Экспорт
	
	Если ТекущиеДанные = Неопределено Тогда
		НастройкиСписка.ВыделеннаяСтрока = Неопределено;
		Возврат;
	КонецЕсли;
		
	НастройкиСписка.ВыделеннаяСтрока = ТекущиеДанные.UID;
		
КонецПроцедуры

Процедура ОбработкаАктивизацииСтрокиДанныхФормы(Знач ЭлементДанныхФормы, ВыделеннаяСтрока) Экспорт
	
	ТекущиеДанные = ЭлементДанныхФормы.ТекущиеДанные; 
	
	Если ТекущиеДанные = Неопределено Тогда
		Возврат;
	КонецЕсли;

	Если ТекущиеДанные.Свойство("ЭтоГруппа") И ТекущиеДанные.ЭтоГруппа Тогда
		Возврат;
	КонецЕсли;
	
	ВыделеннаяСтрока = ТекущиеДанные.UID;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Работа с деревом/таблицей для восстановления развернутых строк.

Процедура ВосстановитьДанныеФормыВПредыдущееСостояние(Форма, Знач ИмяТаблицы, Знач НастройкиСписка) Экспорт
	
	ДанныеФормы = Форма[ИмяТаблицы];
	ЭлементФормы = Форма.Элементы[ИмяТаблицы];
	
	НастройкиДереваФормы = Новый Структура("ИдентификаторВыделеннойСтроки", 0);
	
	Если ТипЗнч(ДанныеФормы) = Тип("ДанныеФормыДерево") Тогда
		НастройкиДереваФормы.Вставить("ИдентификаторыРазвернутыхСтрок", Новый Массив);
		ПолучитьНовыеИдентификаторыСтрок_Дерево(ДанныеФормы, НастройкиСписка, НастройкиДереваФормы); 
	Иначе
		ПолучитьНовыеИдентификаторыСтрок_Таблица(ДанныеФормы, НастройкиСписка, НастройкиДереваФормы);
	КонецЕсли;
	
	Форма.ОбновитьОтображениеДанных(ЭлементФормы); // требуется для выделения текущей строки при фоновом обновлении
	
	Если НастройкиДереваФормы.Свойство("ИдентификаторыРазвернутыхСтрок") Тогда
		РазвернутьСтрокиДереваПослеОбновления(ДанныеФормы, ЭлементФормы, НастройкиДереваФормы);
	Иначе
		ЭлементФормы.ТекущаяСтрока = НастройкиДереваФормы.ИдентификаторВыделеннойСтроки;
	КонецЕсли;
	
КонецПроцедуры

Процедура ВосстановитьСписокВПредыдущееСостояние_Дерево(ТекущаяКоллекция, ТекущийЭлементФормы, Знач НастройкиСписка) Экспорт
	
	НастройкиДереваФормы = Новый Структура("ИдентификаторыРазвернутыхСтрок, ИдентификаторВыделеннойСтроки", Новый Массив, 0);
	ПолучитьНовыеИдентификаторыСтрок_Дерево(ТекущаяКоллекция, НастройкиСписка, НастройкиДереваФормы); 
	
	РазвернутьСтрокиДереваПослеОбновления(ТекущаяКоллекция, ТекущийЭлементФормы, НастройкиДереваФормы);
	
КонецПроцедуры

Процедура ВосcтановитьСписокВПредыдущееСостояние_Таблица(ТекущаяКоллекция, ТекущийЭлементФормы, Знач НастройкиСписка) Экспорт
	
	НастройкиДереваФормы = Новый Структура("ИдентификаторВыделеннойСтроки", 0);
	ПолучитьНовыеИдентификаторыСтрок_Таблица(ТекущаяКоллекция, НастройкиСписка, НастройкиДереваФормы);
	
	ТекущийЭлементФормы.ТекущаяСтрока = НастройкиДереваФормы.ИдентификаторВыделеннойСтроки;
	
КонецПроцедуры

Процедура ОбработатьДляЗаполненияСписок_Дерево(ДеревоПриемник, ТекущийЭлементФормы, Знач ДеревоИсточник, Знач ИсходныеНастройки) Экспорт
	
	НастройкиДереваФормы = Новый Структура("ИдентификаторыРазвернутыхСтрок, ИдентификаторВыделеннойСтроки", Новый Массив, 0);
	ЗаполнитьДеревоНаФорме(ДеревоПриемник, ДеревоИсточник, ИсходныеНастройки, НастройкиДереваФормы); 
	
	РазвернутьСтрокиДереваПослеОбновления(ДеревоПриемник, ТекущийЭлементФормы, НастройкиДереваФормы);
	
КонецПроцедуры

// Обрабатывает дерево на форме. Разворачивает строки после обновления.
//
// Параметры:
//  ТекущийЭлементФормы	 - ТаблицаФормы	 - Элемент формы
//  ДеревоИсточник		 - ДанныеФормыДерево	 - Дерево на форме
//  ИсходныеНастройки	 - 	Структура - Сохраненные настройки для дерева
//
Процедура ОбработатьСуществующийСписок_Дерево(ТекущийЭлементФормы, Знач ДеревоИсточник, Знач ИсходныеНастройки) Экспорт
	
	НастройкиДереваФормы = Новый Структура("ИдентификаторыРазвернутыхСтрок, ИдентификаторВыделеннойСтроки", Новый Массив, 0);
	ПодготовитьРазвернутьДерево(ДеревоИсточник, ИсходныеНастройки, НастройкиДереваФормы); 	
	РазвернутьСтрокиДереваПослеОбновления(ДеревоИсточник, ТекущийЭлементФормы, НастройкиДереваФормы);
	
КонецПроцедуры

Процедура ПередРазворачиваниемУзлаДерева(Дерево, Строка, Данные) Экспорт
	
	СтрокаДерева = Дерево.НайтиПоИдентификатору(Строка);
	Если СтрокаДерева <> Неопределено Тогда
		НайденноеЗначение = Данные.Получить(СтрокаДерева.UID);
		
		Если НайденноеЗначение = Неопределено Тогда
			Данные.Вставить(СтрокаДерева.UID, Строка);
		КонецЕсли;
	КонецЕсли;	
	
КонецПроцедуры

Процедура ПередСворачиваниемУзлаДерева(Дерево, Строка, Данные) Экспорт
	
    // Если узел свернут, хранить его состояние нам уже не требуется
    СтрокаДерева = Дерево.НайтиПоИдентификатору(Строка);
    Если СтрокаДерева <> Неопределено Тогда
        Данные.Удалить(СтрокаДерева.UID);
    КонецЕсли;	
	
КонецПроцедуры

Процедура РазвернутьИлиСвернутьСтрокиДерева(ТекущаяКоллекция, ТекущийЭлементФормы, Знач НастройкиСписка, Знач РазвернутьВсеУзлы) Экспорт
	
	Если РазвернутьВсеУзлы Тогда
		ВосстановитьСписокВПредыдущееСостояние_Дерево(ТекущаяКоллекция, ТекущийЭлементФормы, НастройкиСписка);
	Иначе
		Для Каждого СтрокаДерева Из ТекущаяКоллекция.ПолучитьЭлементы() Цикл
			ТекущийЭлементФормы.Свернуть(СтрокаДерева.ПолучитьИдентификатор());
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Работа с очередью заявок

// Рассчитывает разрешения на управление порядком заявок
//
// Параметры:
//  ДанныеЗаявки			 		- Структура - данные заявки
//  КэшДополнительныхДанных	- Структура - кэш данных формы на клиенте
//  НастройкиФормы			 	- Структура - настройки формы 
// 
// Возвращаемое значение:
//  Структура - данные о разрешениях
//
Функция ОчередьЗаявокРазрешения(Знач ДанныеЗаявки, Знач КэшДополнительныхДанных, Знач НастройкиФормы) Экспорт
	
	Результат = Новый Структура("ВозможностьИзменять, ВозможностьЗафиксировать", Ложь, Ложь);
	
	ВидОчереди = ДанныеЗаявки.ВидОчереди;
	УправлениеПорядком = ДанныеЗаявки.УправлениеПорядком;  
	
	Статус = Неопределено;
	ДанныеЗаявки.Свойство("Статус", Статус); 
	ДоступноУправлениеПорядкомДляДанногоСтатуса = ДоступноУправлениеПорядкомЗаявкиВТекущемСтатусе(Статус);
	
	Если ВидОчереди = ПредопределенноеЗначение("Перечисление.ВидыОчереди.НаправлениеСистемаГруппаЗаказчиков") Тогда		
		Если НЕ ЗначениеЗаполнено(ДанныеЗаявки.ГруппаЗаказчиков) 
			ИЛИ ДанныеЗаявки.ГруппаЗаказчиков = КэшДополнительныхДанных["СсылкаПрочиеЗаказчики"] Тогда
			
			РазрешениеНаИзменение = НастройкиФормы.ДоступныеНаправления.Получить(ДанныеЗаявки.Направление);
			
			Если РазрешениеНаИзменение <> Неопределено 
				И УправлениеПорядком 
				И РазрешениеНаИзменение.РольПользователя <> КэшДополнительныхДанных["ПустаяСсылка_РолиПользователей"] Тогда
				
				Результат.ВозможностьИзменять = ДоступноУправлениеПорядкомДляДанногоСтатуса;
				Результат.ВозможностьЗафиксировать = (РазрешениеНаИзменение.Ответственный ИЛИ РазрешениеНаИзменение.Руководитель)
														И ДоступноУправлениеПорядкомДляДанногоСтатуса;
			КонецЕсли;
		Иначе		
			СвойстваГруппы = НастройкиФормы.ДоступныеГруппыЗаказчиков.Получить(ДанныеЗаявки.ГруппаЗаказчиков);
			
			Если СвойстваГруппы <> Неопределено Тогда
				Результат.ВозможностьИзменять = СвойстваГруппы.Заказчик И ДоступноУправлениеПорядкомДляДанногоСтатуса;
				Результат.ВозможностьЗафиксировать = СвойстваГруппы.Ответственный И ДоступноУправлениеПорядкомДляДанногоСтатуса;
			КонецЕсли;	
		КонецЕсли; 
		
	ИначеЕсли ВидОчереди = ПредопределенноеЗначение("Перечисление.ВидыОчереди.Продукт") 
		ИЛИ ВидОчереди = ПредопределенноеЗначение("Перечисление.ВидыОчереди.ПродуктСистема") Тогда
		
		Результат.ВозможностьИзменять = ДоступноУправлениеПорядкомДляДанногоСтатуса;
		Результат.ВозможностьЗафиксировать = ДоступноУправлениеПорядкомДляДанногоСтатуса;

	ИначеЕсли ВидОчереди = ПредопределенноеЗначение("Перечисление.ВидыОчереди.Филиал") Тогда		
		
		Если ДанныеЗаявки.Филиал = КэшДополнительныхДанных["ФилиалПользователя"]
			ИЛИ КэшДополнительныхДанных["МассивКастомныхКоманд"].Найти(ДанныеЗаявки.Филиал) <> Неопределено Тогда
			
			Результат.ВозможностьИзменять = ДоступноУправлениеПорядкомДляДанногоСтатуса;
			Результат.ВозможностьЗафиксировать = ДоступноУправлениеПорядкомДляДанногоСтатуса;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Формирует параметры перемещаемой заявки
//
// Параметры:
//  ТекущиеДанные - ДанныеФормыКоллеция - текущие данные очереди заявок
//  ВидОчереди	  - ПеречислениеСсылка.ВидыОчереди - вид очереди 
// 
// Возвращаемое значение:
//   Структура - параметры перемещаемой заявки
//
Функция ОчередьЗаявокПараметрыПеремещения(Знач ТекущиеДанные, Знач ВидОчереди) Экспорт 
	
	ПараметрыПеремещения = Новый Структура;
	ПараметрыПеремещения.Вставить("Заявка", ТекущиеДанные.Заявка);
	ПараметрыПеремещения.Вставить("Порядок", ТекущиеДанные.Порядок);
	
	Если ВидОчереди = ПредопределенноеЗначение("Перечисление.ВидыОчереди.НаправлениеСистемаГруппаЗаказчиков") Тогда
		ПараметрыПеремещения.Вставить("Направление", ТекущиеДанные.Направление);
		ПараметрыПеремещения.Вставить("Система", ТекущиеДанные.Система);
		ПараметрыПеремещения.Вставить("ГруппаЗаказчиков", ТекущиеДанные.ГруппаЗаказчиков);
		
	ИначеЕсли ВидОчереди = ПредопределенноеЗначение("Перечисление.ВидыОчереди.Продукт") Тогда	
		ПараметрыПеремещения.Вставить("Продукт", ТекущиеДанные.Продукт);
		
	ИначеЕсли ВидОчереди = ПредопределенноеЗначение("Перечисление.ВидыОчереди.ПродуктСистема") Тогда 
		ПараметрыПеремещения.Вставить("Продукт", ТекущиеДанные.Продукт);
		ПараметрыПеремещения.Вставить("Система", ТекущиеДанные.Система);
		
	ИначеЕсли ВидОчереди = ПредопределенноеЗначение("Перечисление.ВидыОчереди.Филиал") Тогда
		ПараметрыПеремещения.Вставить("Филиал", ТекущиеДанные.Филиал);
		
	ИначеЕсли ВидОчереди = Неопределено Тогда
		ВидОчереди = ПредопределенноеЗначение("Перечисление.ВидыОчереди.Филиал");
		ПараметрыПеремещения.Вставить("Филиал", ТекущиеДанные.ЗначениеГруппировки);		
	КонецЕсли;
	
	ПараметрыПеремещения.Вставить("ВидОчереди", ВидОчереди);
	
	Возврат ПараметрыПеремещения;
	
КонецФункции

#КонецОбласти    

#Область Служебные

Процедура ПодготовитьРазвернутьДерево(Знач ДеревоИсточник, Знач ИсходныеНастройки, НастройкиДерева)
	
	РазвернутыеСтроки = ИсходныеНастройки.РазвернутыеСтроки;
	ВыделеннаяСтрока = ИсходныеНастройки.ВыделеннаяСтрока;
	
	КоллекцияЭлементовИсточник = ДеревоИсточник.ПолучитьЭлементы();
		
	Для Каждого ЭлементДерева Из КоллекцияЭлементовИсточник Цикл
		// Ищем уникальный идентификатор добавляемой строки, в соответствии
		// развернутых строк. Формируем массив идентификаторов строк отображаемого дерева.
		ЭлементСоответствия = РазвернутыеСтроки.Получить(ЭлементДерева.UID);
		Если ЭлементСоответствия <> Неопределено Тогда
			НастройкиДерева.ИдентификаторыРазвернутыхСтрок.Добавить(ЭлементДерева.ПолучитьИдентификатор());
		КонецЕсли;
		
		// Сохраняем идентификатор выделенной строки, ищем по уникальному идентификатору.
		Если ЭлементДерева.UID = ВыделеннаяСтрока Тогда
			НастройкиДерева.ИдентификаторВыделеннойСтроки = ЭлементДерева.ПолучитьИдентификатор();
		КонецЕсли;
		
		ПодготовитьРазвернутьДерево(ЭлементДерева, ИсходныеНастройки, НастройкиДерева);
	КонецЦикла;
		
КонецПроцедуры  

Процедура ЗаполнитьДеревоНаФорме(ДеревоПриемник, Знач ДеревоИсточник, Знач ИсходныеНастройки, НастройкиДерева)
	
	РазвернутыеСтроки = ИсходныеНастройки.РазвернутыеСтроки;
	ВыделеннаяСтрока = ИсходныеНастройки.ВыделеннаяСтрока;
	
	КоллекцияЭлементовИсточник = ДеревоИсточник.ПолучитьЭлементы();
	КоллекцияЭлементовПриемник = ДеревоПриемник.ПолучитьЭлементы();
	
	Для Каждого ЭлементДерева Из КоллекцияЭлементовИсточник Цикл
		НовыйЭлементДерева = КоллекцияЭлементовПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(НовыйЭлементДерева, ЭлементДерева);
		
		// Ищем уникальный идентификатор добавляемой строки, в соответствии
		// развернутых строк. Формируем массив идентификаторов строк отображаемого дерева.
		ЭлементСоответствия = РазвернутыеСтроки.Получить(НовыйЭлементДерева.UID);
		Если ЭлементСоответствия <> Неопределено Тогда
			НастройкиДерева.ИдентификаторыРазвернутыхСтрок.Добавить(НовыйЭлементДерева.ПолучитьИдентификатор());
		КонецЕсли;
		
		// Сохраняем идентификатор выделенной строки, ищем по уникальному идентификатору.
		Если НовыйЭлементДерева.UID = ВыделеннаяСтрока Тогда
			НастройкиДерева.ИдентификаторВыделеннойСтроки = НовыйЭлементДерева.ПолучитьИдентификатор();
		КонецЕсли;
		
		ЗаполнитьДеревоНаФорме(НовыйЭлементДерева, ЭлементДерева, ИсходныеНастройки, НастройкиДерева);
	КонецЦикла;
		
КонецПроцедуры

Процедура ПолучитьНовыеИдентификаторыСтрок_Дерево(Знач ДеревоИсточник, Знач ИсходныеНастройки, НастройкиДерева)
	
	РазвернутыеСтроки = ИсходныеНастройки.РазвернутыеСтроки;
	ВыделеннаяСтрока = ИсходныеНастройки.ВыделеннаяСтрока;
	
	КоллекцияЭлементовИсточник = ДеревоИсточник.ПолучитьЭлементы();
	
	Для Каждого ЭлементДерева Из КоллекцияЭлементовИсточник Цикл		
		// Ищем уникальный идентификатор добавляемой строки, в соответствии
		// развернутых строк. Формируем массив идентификаторов строк отображаемого дерева.
		ЭлементСоответствия = РазвернутыеСтроки.Получить(ЭлементДерева.UID);
		Если ЭлементСоответствия <> Неопределено Тогда
			НастройкиДерева.ИдентификаторыРазвернутыхСтрок.Добавить(ЭлементДерева.ПолучитьИдентификатор());
		КонецЕсли;
		
		// Сохраняем идентификатор выделенной строки, ищем по уникальному идентификатору.
		Если ЭлементДерева.UID = ВыделеннаяСтрока Тогда
			НастройкиДерева.ИдентификаторВыделеннойСтроки = ЭлементДерева.ПолучитьИдентификатор();
		КонецЕсли;
		
		ПолучитьНовыеИдентификаторыСтрок_Дерево(ЭлементДерева, ИсходныеНастройки, НастройкиДерева);
	КонецЦикла;
		
КонецПроцедуры

Процедура ПолучитьНовыеИдентификаторыСтрок_Таблица(Знач ТаблицаИсточник, Знач ИсходныеНастройки, НастройкиДерева)
		
	ВыделеннаяСтрока = ИсходныеНастройки.ВыделеннаяСтрока;
		
	Для Каждого ЭлементДерева Из ТаблицаИсточник Цикл
		// Сохраняем идентификатор выделенной строки, ищем по уникальному идентификатору.
		Если ЭлементДерева.UID = ВыделеннаяСтрока Тогда
			НастройкиДерева.ИдентификаторВыделеннойСтроки = ЭлементДерева.ПолучитьИдентификатор();
		КонецЕсли;
	КонецЦикла;
		
КонецПроцедуры

Процедура РазвернутьСтрокиДереваПослеОбновления(Знач ТекущаяКоллекция, ТекущийЭлементФормы, Знач НастройкиДереваФормы) 
	
	// По идентификатором строк разворачиваем элементы.
	Для Каждого Идентификатор Из НастройкиДереваФормы.ИдентификаторыРазвернутыхСтрок Цикл
		ТекущийЭлементФормы.Развернуть(Идентификатор);
	КонецЦикла;
	
	// Ищем выделенную строку, если она находится в свернутой группе - значение не присваиваем.
	ВыделенныйЭлемент = ТекущаяКоллекция.НайтиПоИдентификатору(НастройкиДереваФормы.ИдентификаторВыделеннойСтроки);
	Если ВыделенныйЭлемент <> Неопределено Тогда
		ЭлементРодитель = ВыделенныйЭлемент.ПолучитьРодителя();
		
		Если ЭлементРодитель <> Неопределено Тогда
			ИдентификаторРодителя = ЭлементРодитель.ПолучитьИдентификатор();
			РодительРазвернут = ТекущийЭлементФормы.Развернут(ИдентификаторРодителя);			
		Иначе
			РодительРазвернут = Истина;
		КонецЕсли;
		
		Если РодительРазвернут Тогда
			ТекущийЭлементФормы.ТекущаяСтрока = НастройкиДереваФормы.ИдентификаторВыделеннойСтроки;
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

Функция ДоступноУправлениеПорядкомЗаявкиВТекущемСтатусе(СтатусЗаявки) 
	
	ЗапрещеноУправлениеПорядком = Новый Массив;
	ЗапрещеноУправлениеПорядком.Добавить(ПредопределенноеЗначение("Справочник.СтатусыОбъектов.Проработка"));
	
	Возврат ЗапрещеноУправлениеПорядком.Найти(СтатусЗаявки) = Неопределено;
	
КонецФункции

#КонецОбласти
