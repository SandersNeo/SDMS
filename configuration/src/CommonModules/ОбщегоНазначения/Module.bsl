///////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2025, ООО ДНС Технологии
// SDMS (Software Development Management System) — это корпоративная система учета разработки и управления проектами 
// Все права защищены. Эта программа и сопроводительные материалы предоставляются 
// в соответствии с условиями лицензии General Public License (GNU GPL v3)
// Текст лицензии доступен по ссылке:
// https://www.gnu.org/licenses/gpl-3.0.html
///////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Серверные процедуры и функции общего назначения:
//  - навигационные ссылки;
//  - работа с объектами и данными информационной базы
//  - раширение для работы с файлами;
//  - трудозатраты;
//  - регламентные и фоновые задания;
//  - вспомогательные процедуры и функции;
//  - внешние компоненты.

#Область ПрограммныйИнтерфейс

// Возвращает имя группы объектов метаданных
//
// Параметры:
//  ОбъектМетаданных	 - ОбъектМетаданныхКонфигурация - объект метаданных
// 
// Возвращаемое значение:
//   Строка - строковое представление имени группы объектов метаданных
//
Функция ИмяГруппыМетаданных(Знач ОбъектМетаданных) Экспорт

	ИмяГруппыМетаданных = "";
	
	Если Метаданные.Константы.Содержит(ОбъектМетаданных) Тогда
		ИмяГруппыМетаданных = "Константа";
	ИначеЕсли Метаданные.Справочники.Содержит(ОбъектМетаданных) Тогда
		ИмяГруппыМетаданных = "Справочник";
	ИначеЕсли Метаданные.Документы.Содержит(ОбъектМетаданных) Тогда
		ИмяГруппыМетаданных = "Документ";
	ИначеЕсли Метаданные.Перечисления.Содержит(ОбъектМетаданных) Тогда
		ИмяГруппыМетаданных = "Перечисление";
	ИначеЕсли Метаданные.Отчеты.Содержит(ОбъектМетаданных) Тогда
		ИмяГруппыМетаданных = "Отчет";
	ИначеЕсли Метаданные.Обработки.Содержит(ОбъектМетаданных) Тогда
		ИмяГруппыМетаданных = "Обработка";
	ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных) Тогда
		ИмяГруппыМетаданных = "ПланВидовХарактеристик";
	ИначеЕсли Метаданные.РегистрыСведений.Содержит(ОбъектМетаданных) Тогда
		ИмяГруппыМетаданных = "РегистрСведений";
	ИначеЕсли Метаданные.РегистрыНакопления.Содержит(ОбъектМетаданных) Тогда
		ИмяГруппыМетаданных = "РегистрНакопления";
	КонецЕсли;
	
	Возврат ИмяГруппыМетаданных;

КонецФункции

// Рекурсивно находит ближайший проект из основания заявки
//
// Параметры:
//  Ссылка	 - СправочникСсылка.ЗаявкаНаРазработку, СправочникСсылка.Проекты, ДокументСсылка.ВнутреннееЗадание,
//  ДокументСсылка.Задача - Ссылка на объект для которого нужно найти Проект
// 
// Возвращаемое значение:
// СправочникСсылка.Проекты - Ссылка на ближайший проект. Если проект не задан возвращается пустая ссылка
//
Функция НайтиБлижайшийПроект(Ссылка) Экспорт
	
	Основание = ЗначениеРеквизитаОбъекта(Ссылка, "ОбъектОснование");
	
	Если ЗначениеЗаполнено(Основание) Тогда
		Если ТипЗнч(Основание) = Тип("СправочникСсылка.Проекты") Тогда
			Проект = Основание;
		Иначе
			Проект = НайтиБлижайшийПроект(Основание);
		КонецЕсли;
	Иначе
		Проект = Справочники.Проекты.ПустаяСсылка();
	КонецЕсли;
	
	Возврат Проект;
	
КонецФункции

// Удаляет префикс и нули из номера объекта
//
// Параметры:
//  Номер	 - Строка	 - номер объекта
//  Префикс	 - Строка	 - префикс объекта
// 
// Возвращаемое значение:
//  Строка - короткий номер объекта
//
Функция ПолучитьКороткийНомер(Знач Номер, Знач Префикс) Экспорт
	
	НомерБезПрефикса = СтрЗаменить(Номер, Префикс, "");
	
	Возврат ОбщегоНазначенияКлиентСервер.ПривестиКЧислу(НомерБезПрефикса, 9);

КонецФункции

// Возвращает значение реквизита, прочитанного из информационной базы по ссылке на объект.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
//
// Функция не предназначена для получения значений реквизитов пустых ссылок.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Произвольный    - зависит от типа значения прочитанного реквизита.
// 
Функция ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = ЗначенияРеквизитовОбъекта(Ссылка, ИмяРеквизита);
	Возврат Результат[СтрЗаменить(ИмяРеквизита, ".", "")];
	
КонецФункции

// Возвращает структуру, содержащую значения реквизитов прочитанные из информационной базы
// по ссылке на объект.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Функция не предназначена для получения значений реквизитов пустых ссылок.
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//              требований к свойствам структуры.
//              Например, "Код, Наименование, Родитель".
//            - Структура, ФиксированнаяСтруктура - в качестве ключа передается
//              псевдоним поля для возвращаемой структуры с результатом, а в качестве
//              значения (опционально) фактическое имя поля в таблице.
//              Если значение не определено, то имя поля берется из ключа.
//            - Массив, ФиксированныйМассив - имена реквизитов в формате требований
//              к свойствам структуры.
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
//              Если строка затребованных реквизитов пуста, то возвращается пустая структура.
//              Если в качестве объекта передана пустая ссылка, то все реквизиты вернутся со значением Неопределено.
//
Функция ЗначенияРеквизитовОбъекта(Ссылка, Знач Реквизиты) Экспорт
	
	ТипРеквизитов = ТипЗнч(Реквизиты);
	
	Если ТипРеквизитов = Тип("Строка") Тогда
		Если ПустаяСтрока(Реквизиты) Тогда
			Возврат Новый Структура;
		КонецЕсли;
		
		Реквизиты = СтрРазделить(Реквизиты, ",", Ложь);
		ТипРеквизитов = Тип("Массив");
	КонецЕсли;
	
	СтруктураРеквизитов = Новый Структура;
	
	Если ТипРеквизитов = Тип("Массив") ИЛИ ТипРеквизитов = Тип("ФиксированныйМассив") Тогда
		Для Каждого Реквизит Из Реквизиты Цикл
			СтруктураРеквизитов.Вставить(СтрЗаменить(Реквизит, ".", ""), Реквизит);
		КонецЦикла;
		
	ИначеЕсли ТипРеквизитов = Тип("Структура") ИЛИ ТипРеквизитов = Тип("ФиксированнаяСтруктура") Тогда
		СтруктураРеквизитов = Реквизиты;
	Иначе
		ВызватьИсключение СтрШаблон("Неверный тип второго параметра Реквизиты: %1", Строка(ТипРеквизитов));
	КонецЕсли;
	
	МассивПолей = Новый Массив;
	ШаблонПоля = 
	"
	|	%1 КАК %2";
	
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		Если ЗначениеЗаполнено(КлючИЗначение.Значение) Тогда
			ИмяПоля = СокрЛП(КлючИЗначение.Значение);
		Иначе
			ИмяПоля = СокрЛП(КлючИЗначение.Ключ);
		КонецЕсли;
		
		Псевдоним = СокрЛП(КлючИЗначение.Ключ);
		
		ТекстПоля = СтрШаблон(ШаблонПоля, ИмяПоля, Псевдоним);
		МассивПолей.Добавить(ТекстПоля);
	КонецЦикла;
	
	ТекстПолей = СтрСоединить(МассивПолей, ",");
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|" + ТекстПолей + "
	|ИЗ
	|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК ПсевдонимЗаданнойТаблицы
	|ГДЕ
	|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка
	|";
	
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Результат = Новый Структура;
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		Результат.Вставить(КлючИЗначение.Ключ);
	КонецЦикла;
	
	ЗаполнитьЗначенияСвойств(Результат, Выборка);
	
	Возврат Результат;
	
КонецФункции

// Возвращает количество потоков обработки очереди событий
// 
// Возвращаемое значение:
//  Число - КоличествоПотоков
//
Функция КоличествоПотоковОбработкиОчередиСобытий() Экспорт

	КоличествоПотоков = Константы.КоличествоПотоковОбработкиОчередиСобытий.Получить();
	КоличествоПотоков = ?(КоличествоПотоков = 0, 1, КоличествоПотоков);
	
    Возврат КоличествоПотоков;
	
КонецФункции

// Останавливает выполнение кода на заданное время.
//
// Параметры:
//  ВремяПриостановки - Число - время ожидания в секундах.
//
Процедура Пауза(Знач ВремяПриостановки) Экспорт
    
    ТекущийСеансИнформационнойБазы = ПолучитьТекущийСеансИнформационнойБазы();
    ФоновоеЗадание = ТекущийСеансИнформационнойБазы.ПолучитьФоновоеЗадание();
    
    Если ФоновоеЗадание = Неопределено Тогда
        Параметры = Новый Массив;
        Параметры.Добавить(ВремяПриостановки);
        ФоновоеЗадание = ФоновыеЗадания.Выполнить("ОбщегоНазначения.Пауза", Параметры);
    КонецЕсли;
        
    Попытка
        ФоновоеЗадание.ОжидатьЗавершенияВыполнения(ВремяПриостановки);
    Исключение
        Возврат;
    КонецПопытки;
    
КонецПроцедуры

// Получает блокирующего пользователя при попытке применить к объекту ЗаблокироватьДанныеДляРедактирования
//
// Параметры:
//  ТекстОшибки - Строка - описание ошибки
// 
// Возвращаемое значение:
//  Строка - блокирующий пользователь
//
Функция ПолучитьБлокирующегоПользователя(Знач ТекстОшибки) Экспорт
	
	БлокирующийПользователь = "";
	МассивСтрок = СтрРазделить(СтрПолучитьСтроку(ТекстОшибки, 2), ",");
	
	Для Каждого Подстрока Из МассивСтрок Цикл
		Если СтрНачинаетсяС(СокрЛ(Подстрока), "пользователь") Тогда
			МассивПодстрокСтрокиСПользователем = СтрРазделить(Подстрока, ":");
			БлокирующийПользователь = МассивПодстрокСтрокиСПользователем[1];
		КонецЕсли;
	КонецЦикла;
	
	Возврат СокрЛП(БлокирующийПользователь);
	
КонецФункции
  
// Получить текст из HTML кода
//
// Параметры:
//  HTMLText - Строка - html код
// 
// Возвращаемое значение:
//   Строка - полученный текст 
//
Функция ПолучитьТекстИзHTML(Знач HTMLText) Экспорт  
	
	Результат = "";  
	ТекстHTML = СокрЛП(HTMLText);  
	
	Если НЕ ПустаяСтрока(ТекстHTML) Тогда
		Попытка		
			HTML = Новый COMОбъект("HTMLFile");  
			HTML.Open("text/html");  
			HTML.Write(ТекстHTML);  
			
			Если HTML.documentElement <> Неопределено Тогда  
				Результат = Строка(HTML.body.outerText);  
				Результат = СтрЗаменить(Результат, Символы.ВК, "");  
			КонецЕсли; 
		Исключение
			Результат = "";		
		КонецПопытки;
	КонецЕсли;      
	
	Возврат СокрЛП(Результат);  
	
КонецФункции
 
// Возвращает полную ссылку на объект с использованием адреса публикации ИБ.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - ссылка на объект ИБ.
//
// Возвращаемое значение:
//  Строка.
//
Функция ПолучитьHTTPСсылкуНаОбъект(Знач Ссылка) Экспорт
	
	Если ЗначениеЗаполнено(Ссылка) Тогда
		АдресПубликации = WebОкружениеВызовСервера.АдресПубликацииИнформационнойБазы();
		НавигационнаяСсылка = ПолучитьНавигационнуюСсылку(Ссылка);
		
		Результат = СтрШаблон("%1#%2", АдресПубликации, НавигационнаяСсылка);
	Иначе
		Результат = "";
	КонецЕсли;
	
	Возврат Результат;	
	
КонецФункции

// Функция - Получить причину изменения статуса
//
// Параметры:
//  Ссылка	 - Задача,Заявка,Проект,Вн.Задание - Ссылка на объект
//  Статус	 - Справочник.СтатусыОбъектов - Текущий статус объекта
// 
// Возвращаемое значение:
// Строка,Неопределено - Возвращает строковое представление причины изменения статуса.
// Если запись не найдена, возвращает неопределено
//
Функция ПолучитьПричинуИзмененияСтатуса(Знач Ссылка, Знач Статус) Экспорт
	
	Причина = Неопределено;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ПРЕДСТАВЛЕНИЕ(ПричиныИзмененияСтатусаОбъектовСрезПоследних.ПричинаИзмененияСтатуса) КАК ПричинаИзмененияСтатусаПредставление
	|ИЗ
	|	РегистрСведений.ПричиныИзмененияСтатусаОбъектов.СрезПоследних(
	|			,
	|			Объект = &Объект
	|				И Статус = &Статус) КАК ПричиныИзмененияСтатусаОбъектовСрезПоследних";
	Запрос.УстановитьПараметр("Объект", Ссылка);
	Запрос.УстановитьПараметр("Статус", Статус);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		Причина = СтрСоединить(РезультатЗапроса.Выгрузить().ВыгрузитьКолонку("ПричинаИзмененияСтатусаПредставление"), ", ");
	КонецЕсли;
	
	Возврат Причина;
	
КонецФункции

// По формату картинки определяет и возвращает расширение для файла.
//
// Параметры:
//  Формат        - ФорматКартинки - значение типа ФорматКартинки.
//  ДобавитьТочку - Булево - признак необходимости добавления перед расширением символа точки.
//
// Возвращаемое значение:
//  Строка с расширением.
//
Функция ПолучитьРасширениеФайлаПоФорматуКартинки(Формат, ДобавитьТочку = Ложь) Экспорт
	
	Если Формат = ФорматКартинки.BMP Тогда
		Расширение = "bmp";
		
	ИначеЕсли Формат = ФорматКартинки.EMF Тогда
		Расширение = "emf";
		
	ИначеЕсли Формат = ФорматКартинки.GIF Тогда
		Расширение = "gif";
		
	ИначеЕсли Формат = ФорматКартинки.Icon Тогда
		Расширение = "ico";
		
	ИначеЕсли Формат = ФорматКартинки.JPEG Тогда
		Расширение = "jpg";
		
	ИначеЕсли Формат = ФорматКартинки.PNG Тогда
		Расширение = "png";
		
	ИначеЕсли Формат = ФорматКартинки.SVG Тогда
		Расширение = "svg";
		
	ИначеЕсли Формат = ФорматКартинки.TIFF Тогда
		Расширение = "tiff";
		
	ИначеЕсли Формат = ФорматКартинки.WMF Тогда
		Расширение = "wmf";
		
	Иначе
		Расширение = "file";
	КонецЕсли;
	
	Если ДобавитьТочку = Истина Тогда
		Расширение = "." + Расширение;
	КонецЕсли;
	
	Возврат Расширение;
	
КонецФункции
   
// Получает шаблоны электронного письма с общего макета
// 
// Возвращаемое значение:
//   Структура - структура шаблонов 
//
Функция ПолучитьШаблоныЭлектронногоПисьма() Экспорт
	
	Шаблоны = Новый Структура;
	
	ШаблонЭлектронногоПисьма = ПолучитьОбщийМакет("ШаблоныЭлектронныхПисем");
	ОбластьШапка = ШаблонЭлектронногоПисьма.ПолучитьОбласть("Шапка");
	ОбластьШапка.УдалитьСтроку(ОбластьШапка.КоличествоСтрок());
	ОбластьШапка.УдалитьСтроку(1);
	Шаблоны.Вставить("ОбластьШапка", ОбластьШапка.ПолучитьТекст());
	
	ОбластьТелоСообщения = ШаблонЭлектронногоПисьма.ПолучитьОбласть("ТелоСообщения");
	ОбластьТелоСообщения.УдалитьСтроку(ОбластьТелоСообщения.КоличествоСтрок());
	ОбластьТелоСообщения.УдалитьСтроку(1);
	Шаблоны.Вставить("ОбластьТелоСообщения", ОбластьТелоСообщения.ПолучитьТекст());
	
	ОбластьПодвал = ШаблонЭлектронногоПисьма.ПолучитьОбласть("Подвал");
	ОбластьПодвал.УдалитьСтроку(ОбластьПодвал.КоличествоСтрок());
	ОбластьПодвал.УдалитьСтроку(1);
	Шаблоны.Вставить("ОбластьПодвал", ОбластьПодвал.ПолучитьТекст());
	
	ОбластьСтрокаПервыйУровеньПроект = ШаблонЭлектронногоПисьма.ПолучитьОбласть("СтрокаПервыйУровеньПроект");
	ОбластьСтрокаПервыйУровеньПроект.УдалитьСтроку(ОбластьСтрокаПервыйУровеньПроект.КоличествоСтрок());
	ОбластьСтрокаПервыйУровеньПроект.УдалитьСтроку(1);
	Шаблоны.Вставить("ОбластьСтрокаПервыйУровеньПроект", ОбластьСтрокаПервыйУровеньПроект.ПолучитьТекст());
	
	ОбластьСтрокаПервыйУровеньНаправление = ШаблонЭлектронногоПисьма.ПолучитьОбласть("СтрокаПервыйУровеньНаправление");
	ОбластьСтрокаПервыйУровеньНаправление.УдалитьСтроку(ОбластьСтрокаПервыйУровеньНаправление.КоличествоСтрок());
	ОбластьСтрокаПервыйУровеньНаправление.УдалитьСтроку(1);
	Шаблоны.Вставить("ОбластьСтрокаПервыйУровеньНаправление", ОбластьСтрокаПервыйУровеньНаправление.ПолучитьТекст());
	
	ОбластьСтрокаВторойУровень = ШаблонЭлектронногоПисьма.ПолучитьОбласть("СтрокаВторойУровеньТриКолонки");
	ОбластьСтрокаВторойУровень.УдалитьСтроку(ОбластьСтрокаВторойУровень.КоличествоСтрок());
	ОбластьСтрокаВторойУровень.УдалитьСтроку(1);
	Шаблоны.Вставить("ОбластьСтрокаВторойУровень", ОбластьСтрокаВторойУровень.ПолучитьТекст());
	
	ОбластьСтрокаТретийУровень = ШаблонЭлектронногоПисьма.ПолучитьОбласть("СтрокаТретийУровеньТриКолонки");
	ОбластьСтрокаТретийУровень.УдалитьСтроку(ОбластьСтрокаТретийУровень.КоличествоСтрок());
	ОбластьСтрокаТретийУровень.УдалитьСтроку(1);
	Шаблоны.Вставить("ОбластьСтрокаТретийУровень", ОбластьСтрокаТретийУровень.ПолучитьТекст());
	
	ОбластьНачалоТаблицы = ШаблонЭлектронногоПисьма.ПолучитьОбласть("НачалоОбластиДляНесколькихКолонок");
	ОбластьНачалоТаблицы.УдалитьСтроку(ОбластьНачалоТаблицы.КоличествоСтрок());
	ОбластьНачалоТаблицы.УдалитьСтроку(1);
	Шаблоны.Вставить("ОбластьНачалоТаблицы", ОбластьНачалоТаблицы.ПолучитьТекст());
	
	ОбластьКонецТаблицы = ШаблонЭлектронногоПисьма.ПолучитьОбласть("КонецОбластиДляНесколькихКолонок");
	ОбластьКонецТаблицы.УдалитьСтроку(ОбластьКонецТаблицы.КоличествоСтрок());
	ОбластьКонецТаблицы.УдалитьСтроку(1);
	Шаблоны.Вставить("ОбластьКонецТаблицы", ОбластьКонецТаблицы.ПолучитьТекст());
	
	ОбластьИтогПоПроектуНаправлению = ШаблонЭлектронногоПисьма.ПолучитьОбласть("Вставка");
	ОбластьИтогПоПроектуНаправлению.УдалитьСтроку(ОбластьИтогПоПроектуНаправлению.КоличествоСтрок());
	ОбластьИтогПоПроектуНаправлению.УдалитьСтроку(1);
	Шаблоны.Вставить("ОбластьИтогПоПроектуНаправлению", ОбластьИтогПоПроектуНаправлению.ПолучитьТекст());
	
	Возврат Шаблоны;
	
КонецФункции

// Возвращает ссылку предопределенного элемента по его полному имени.
// Предопределенные элементы могут содержаться только в следующих объектах:
//   - справочники;
//   - планы видов характеристик;
//   - планы счетов;
//   - планы видов расчета.
// После изменения состава предопределенных следует выполнить метод
// ОбновитьПовторноИспользуемыеЗначения(), который сбросит кэш ПовтИсп в текущем сеансе.
//
// Параметры:
//   ПолноеИмяПредопределенного - Строка - полный путь к предопределенному элементу, включая его имя.
//     Формат аналогичен функции глобального контекста ПредопределенноеЗначение().
//     Например:
//       "Справочник.ВидыКонтактнойИнформации.EmailПользователя"
//       "ПланСчетов.Хозрасчетный.Материалы"
//       "ПланВидовРасчета.Начисления.ОплатаПоОкладу".
//
// Возвращаемое значение: 
//   ЛюбаяСсылка - ссылка на предопределенный элемент.
//   Неопределено - если предопределенный элемент есть в метаданных, но не создан в ИБ.
//
Функция ПредопределенныйЭлемент(Знач ПолноеИмяПредопределенного) Экспорт
	
	ИмяПредопределенного = ВРег(ПолноеИмяПредопределенного);
	
	Точка = Найти(ИмяПредопределенного, ".");
	ИмяКоллекции = Лев(ИмяПредопределенного, Точка - 1);
	ИмяПредопределенного = Сред(ИмяПредопределенного, Точка + 1);
	
	Точка = Найти(ИмяПредопределенного, ".");
	ИмяТаблицы = Лев(ИмяПредопределенного, Точка - 1);
	ИмяПредопределенного = Сред(ИмяПредопределенного, Точка + 1);
	
	ТекстЗапроса = "ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1 Ссылка ИЗ &ПолноеИмяТаблицы ГДЕ ИмяПредопределенныхДанных = &ИмяПредопределенного";
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПолноеИмяТаблицы", ИмяКоллекции + "." + ИмяТаблицы);
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("ИмяПредопределенного", ИмяПредопределенного);
	
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		Возврат Неопределено;
	Иначе
		Возврат Результат.Выгрузить()[0].Ссылка;
	КонецЕсли;
	
КонецФункции

// Вызывает исключение, если дата объекта БД меньше даты запрета изменения данных
//
// Параметры:
//  ДатаЗаписи - Дата - дата записи базы данных
//  ОтключитьПроверкуЗапретаИзменения - Булево - флаг, если Истина не проводим проверку. 
//
Процедура ПроверитьДатуЗапретаИзмененияДанных(Знач ДатаЗаписи, Знач ОтключитьПроверкуЗапретаИзменения) Экспорт
	
	Если ОтключитьПроверкуЗапретаИзменения Тогда
		Возврат;
	КонецЕсли;
		
	ДатаЗапретаИзмененияДанных = Константы.ДатаЗапретаИзмененияДанных.Получить();
		
	Если ЗначениеЗаполнено(ДатаЗапретаИзмененияДанных) И НачалоДня(ДатаЗаписи) <= ДатаЗапретаИзмененияДанных Тогда
		ТекстСообщения = "Изменение данных за прошлый месяц недоступно.";
		ВызватьИсключение ТекстСообщения;
	КонецЕсли;
	
КонецПроцедуры

// Читает содержимое JSON и преобразовывает его в структуру или соответствие.
//
// Параметры:
//  ТекстJSON    - Строка - текст в формате JSON.
//  Соответствие - Булево - преобразовать в соответствие. Если параметру установлено
//                 значение Ложь, данные преобразуются в Структуру.
//
// Возвращаемое значение:
//  Структура или Соответствие.
//
Функция ПрочитатьСодержимоеJSON(Знач ТекстJSON, Знач Соответствие = Ложь) Экспорт
	
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(ТекстJSON);
	Данные = ПрочитатьJSON(ЧтениеJSON, Соответствие);
	
	ЧтениеJSON.Закрыть();
	
	Возврат Данные;
	
КонецФункции

// Создает COM-объект Excel.Application для работы с Microsoft Excel.
//  Актуально только для ОС Windows. Во всех других будет возвращено Неопределено.
//
// Параметры:
//  БезопасныйРежим		 - Булево	 - признак открытия документа с запротом на выполнение
//  	макросов.
//  Видимость			 - Булево	 - показывать на экране запущенное приложение.
//  ВыводитьСообщения	 - Булево	 - отображать сообщения от приложения Excel в момент
//  	его работы.
// 
// Возвращаемое значение:
//  COMОбъект - если при создании объекта возникла ошибка или ОС отличная от Windows,
//  возвращает Неопределено.
//
Функция СоздатьОбъектExcelApplication(Знач БезопасныйРежим = Истина, Знач Видимость = Ложь, Знач ВыводитьСообщения = Ложь) Экспорт
	
	ExcelApplication = Неопределено;
	
	Попытка
		ExcelApplication = Новый COMОбъект("Excel.Application");
		
		Если БезопасныйРежим Тогда
			ExcelApplication.AutomationSecurity = 3;
		КонецЕсли;
		
		ExcelApplication.Visible = Видимость;
		ExcelApplication.DisplayAlerts = ВыводитьСообщения;
		ExcelApplication.ReferenceStyle = 1;
	Исключение
		Информация = ИнформацияОбОшибке();
		ПодробноеПредставление = ПодробноеПредставлениеОшибки(Информация);
		
		ЗаписьЖурналаРегистрации("ОбщегоНазначения.СоздатьОбъектExcelApplication",
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставление);
	КонецПопытки;
	
	Возврат ExcelApplication;
	
КонецФункции

// Удаляет из строки домен с точкой перед ним
//
// Параметры:
//  ИсходнаяСтрока  - Строка - любая строка, которая может содержать домен
//
// Возвращаемое значение:
//   Строка   - Строка без домена
//
Функция СтрокаБезДомена(Знач ИсходнаяСтрока) Экспорт
	
	Домен = Константы.ДоменСервераИнформационнойБазы.Получить();	
	ДоменСТочкой = СтрШаблон(".%1", Домен);
	
	Возврат СтрЗаменить(ИсходнаяСтрока, ДоменСТочкой, "");

КонецФункции

// Формирует текст JSON на основании структуры или соответствия
//
// Параметры:
//  Данные - Структура, Соответствие - Данные для формирования
// 
// Возвращаемое значение:
//  Строка - Строка в формате JSON
//
Функция СформироватьТекстJSON(Знач Данные, Знач ИмяСобытия) Экспорт
		
	ПараметрыЗаписиJSON = Новый ПараметрыЗаписиJSON(, " ", ,
		ЭкранированиеСимволовJSON.СимволыВнеBMP, Истина, Истина, Ложь, , Истина);
		
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку(ПараметрыЗаписиJSON);
	
	Попытка
		ЗаписатьJSON(ЗаписьJSON, Данные);
		ТекстJSON = ЗаписьJSON.Закрыть();
	Исключение
		ТекстJSON = "";	
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ЗаписьЖурналаРегистрации(ИмяСобытия, УровеньЖурналаРегистрации.Ошибка, , , ТекстОшибки); 
	КонецПопытки;
	
	Возврат ТекстJSON;
	
КонецФункции

Функция ТекущаяДатаСоСдвигом() Экспорт
	
	ТекущаяДата = ТекущаяДатаСеанса();
	СдвигЧасовогоПояса = ПовторноеИспользованиеВызовСервера.ПолучитьСдвигЧасовогоПояса();
	
	Возврат ТекущаяДатаСеанса() + СдвигЧасовогоПояса * 3600;
	
КонецФункции

// Деинициализирует COM-объект Excel.Application
//
// Параметры:
//  Excel		 - COMОбъект	 - com-объект ExcelApplication
//  КнигаExcel	 - COMОбъект	 - com-объект книги
//  ЛистExcel	 - COMОбъект	 - com-объект листа
//  Сохранить	 - Булево	 - сохранить книгу перед закрытием или нет
//
Процедура УничтожитьОбъектExcelApplication(Excel, КнигаExcel = Неопределено,
	ЛистExcel = Неопределено, Знач Сохранить = Ложь) Экспорт
	
	Если ЛистExcel <> Неопределено Тогда
		ЛистExcel = Неопределено;
	КонецЕсли;
	
	Попытка
		Если Сохранить Тогда
			КнигаExcel.Save();
		КонецЕсли;
		
		Excel.WorkBooks.Close();
		Excel.Quit();
		Excel = Неопределено;
	Исключение
		Excel = Неопределено;
	КонецПопытки;
	
	Если КнигаExcel <> Неопределено Тогда
		КнигаExcel = Неопределено;
	КонецЕсли;
	
КонецПроцедуры

// Проверяет ограничение на уровень вложенности объекта
//
// Параметры:
//  ОбъектОснование	 - СправочникСсылка.Проект, ДокументСсылка.ВнутреннееЗадание - проверяемый объект
//  Тип	 - Тип - тип исходного объекта
// Возвращаемое значение:
//  Результат - Структура
//   *УровеньПревышен - Булево                    
//   *Сообщение - Строка
//
Функция УровеньВложенностиПревышен(Знач Тип, Знач ОбъектОснование) Экспорт
	
	Результат = Новый Структура("УровеньПревышен, Сообщение", Ложь, "");  
	
	Если НЕ ЗначениеЗаполнено(ОбъектОснование) Тогда  
		Возврат Результат;
	КонецЕсли;
	
	// Получим максимальный уровень вложенности
	Если Тип = Тип("СправочникСсылка.Проекты") Тогда
		ДопустимыйУровеньВложенности = Справочники.Проекты.МаксимальныйУровеньВложенности();
	Иначе 
		ДопустимыйУровеньВложенности = Документы.ВнутреннееЗадание.МаксимальныйУровеньВложенности();
	КонецЕсли;
		
	// Счетчик уровней вложенности друг в друга
	УровеньВложенности = 0;  
		
    // Если у проверяемого проекта заполнен объект-основание, то уровень вложенности уже равен 1
	Если ЗначениеЗаполнено(ОбъектОснование) Тогда
		УровеньВложенности = 2;
		
		Пока УровеньВложенности <= ДопустимыйУровеньВложенности Цикл
		    ОбъектОснование = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ОбъектОснование, "ОбъектОснование");
			
			// У внутреннего задания основанием может быть и проект и внутреннее задание,
			// нужно смотреть именно в рамках одного типа объекта.
			Если НЕ ЗначениеЗаполнено(ОбъектОснование) ИЛИ Тип <> ТипЗнч(ОбъектОснование) Тогда
				Прервать;
			КонецЕсли;
			
			ОбщегоНазначенияКлиентСервер.УвеличитьЗначение(УровеньВложенности);
		КонецЦикла;
	КонецЕсли;
	
	// Если превышен уровень вложенности
	Если УровеньВложенности > ДопустимыйУровеньВложенности Тогда
		Результат.УровеньПревышен = Истина;
		Результат.Сообщение = "Иерархия вложенности не может превышать " +
			СтрокаСЧислом("%1-го уровня.;%1-го уровня.;%1-х уровней.;%1-х уровней.;%1-ти уровней.;%1-ти уровней.",
				ДопустимыйУровеньВложенности, ВидЧисловогоЗначения.Количественное);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Экранирует символы в исходном тексте JSON.
//
// Параметры:
//  ТекстJSON	 - Строка	 - текст в формает JSON.
// 
// Возвращаемое значение:
//  Строка - экранированных JSON
//
Функция ЭкранироватьСимволыJSON(Знач ТекстJSON) Экспорт
	
	ТекстJSON = СтрЗаменить(ТекстJSON, "\", "\\");
	ТекстJSON = СтрЗаменить(ТекстJSON, Символы.ПС, "\n");
	ТекстJSON = СтрЗаменить(ТекстJSON, Символы.Таб, " ");
	ТекстJSON = СтрЗаменить(ТекстJSON, """", "\""");
	ТекстJSON = СтрЗаменить(ТекстJSON, "'", "\""");
	
	Возврат ТекстJSON;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Работа с формой, элементами формы, свойствами элементов формы

// Заполняет группу формы элементами для приглашения пользователя установить
// расширение работы с файлами.
//
// Параметры:
//  Форма       - УправляемаяФорма - форма-приемник элементов.
//  ГруппаФормы - ГруппаФорма - группа, в которую будут добавлены элемент формы.
//
Процедура ЗаполнитьГруппуУстановкиРасширенияРаботыСФайлами(Форма, ГруппаФормы) Экспорт
	
	// Чтобы исключить дублирование имен элементов на одной форме
	Индекс = СтрЗаменить(Новый УникальныйИдентификатор, "-", "");
	
	// Установка родительской группе основного цвета информационных надписей
	ГруппаФормы.ЦветФона = ЦветаСтиля.ЦветФонаБлоковИнформационнойПанели;
	
	ТипДекорацияФормы = Тип("ДекорацияФормы");
	
	// Картинка Информация32
	ИмяЭлемента = "КартинкаПриглашениеУстановкиРасширения_" + Индекс;
	Элемент = Форма.Элементы.Добавить(ИмяЭлемента, ТипДекорацияФормы, ГруппаФормы);
	Элемент.Вид = ВидДекорацииФормы.Картинка;
	Элемент.Картинка = БиблиотекаКартинок.Информация32;
	
	// Текст приглашения с гиперссылкой
	ИмяЭлемента = "НадписьПриглашениеУстановкиРасширения_" + Индекс;
	Элемент = Форма.Элементы.Добавить(имяЭлемента, ТипДекорацияФормы, ГруппаФормы);
	Элемент.Вид = ВидДекорацииФормы.Надпись;
	Элемент.Ширина = 65;
	Элемент.Высота = 4;
	Элемент.АвтоМаксимальнаяШирина = Ложь;
	
	// Текст для форматированной строки надписи
	Текст = "Управлять присоединенными файлами будет удобнее, если "
		+ "установить дополнение браузера ""Расширение для работы с файлами"". "
		+ "Оно упростит выполнение операций и добавит возможность работать с "
		+ "группой файлов. ";
	
	ТекстСсылки = "Чтобы начать установку, нужно нажать на эту ссылку и следовать инструкциям.";
	
	ТекстСообщения = Новый ФорматированнаяСтрока(Текст, , ЦветаСтиля.ПоясняющийТекст);
	Ссылка = ОбщегоНазначенияКлиентСервер.ТекстСсылкиУстановкиРасширенияРаботыСФайлами();
	СтрокаСсылки = Новый ФорматированнаяСтрока(ТекстСсылки, , , , Ссылка);
	
	Элемент.Заголовок = Новый ФорматированнаяСтрока(ТекстСообщения, СтрокаСсылки);
	
	// Подключение обработчика нажатия навигационной ссылки
	Элемент.УстановитьДействие("ОбработкаНавигационнойСсылки", "Подключаемый_УстановкаРасширенияРаботыСФайламиНажатие");
	
	// Временно скроем информационную панель с приглашением установки расширения.
	// Позже на клиенте, после проверки подключенного расширения, определим, показывать
	// эту панель или нет.
	ГруппаФормы.Видимость = Ложь;
	
КонецПроцедуры

// Проверяет необходимость отображения пользователю окна с описанием назначения
// объектов.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - ссылка на объект БД.
//
// Возвращаемое значение:
//  Булево. Истина - необходимо показать. В противном случае Ложь.
//
Функция НеобходимоПоказатьОписаниеНазначенияОбъектов(Знач Ссылка) Экспорт
	
	ИмяМетаданных = Ссылка.Метаданные().ПолноеИмя();
	КлючНастроек = "ОткрытьОписаниеНазначенияОбъектов";
	
	Настройки = ОбщегоНазначенияВызовСервера.ЗагрузитьНастройкиДанныхФормы(ИмяМетаданных, КлючНастроек);
	
	Возврат (Настройки = Неопределено);

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры проверки заполнения и записи объектов

// Удаляет дубли строк в табличных частях
//
// Параметры:
//  ТабличнаяЧасть		 - 	 - Табличная часть	 - таблицачная часть объекта
//  СворачиваемыеПоля	 - Строка - имена колонок, по которым требуется удалить дубли
//  КолонкиСуммирования	 - Строка - имена колонок, по которым значения будут суммированы
//
Процедура ОчисткаДублейТабличнойЧасти(ТабличнаяЧасть, СворачиваемыеПоля, КолонкиСуммирования = Неопределено) Экспорт
	
	// Автоматическая очистка дублей
	Таблица = ТабличнаяЧасть.Выгрузить();
	КоличествоСтрокДоСвертки = Таблица.Количество();
	
	Таблица.Свернуть(СворачиваемыеПоля, КолонкиСуммирования);
	
	Если КоличествоСтрокДоСвертки > Таблица.Количество() Тогда
		ТабличнаяЧасть.Загрузить(Таблица);
	КонецЕсли;
	
КонецПроцедуры

// Выполняет удаление реквизитов, описанных в массиве НепроверяемыеРеквизиты
// из массива реквизитов, описанных в массиве ПроверяемыеРеквизиты. Вызывается
// из процедуры ОбработкаПроверкиЗаполнения модулей объектов.
//
// Параметры:
//  ПроверяемыеРеквизиты   - Массив - реквизиты, обязательные к проверке заполнения.
//  НепроверяемыеРеквизиты - Массив - реквизиты, исключаемые из проверки.
//
Процедура УдалитьНепроверяемыеРеквизиты(ПроверяемыеРеквизиты, НепроверяемыеРеквизиты) Экспорт
	
	Для Каждого ЭлементМассива Из НепроверяемыеРеквизиты Цикл
		// Перед удалением реквизита из массива необходимо проверить, что он там есть
		// (не был удален ранее платформой или в коде).
		ПорядковыйНомер = ПроверяемыеРеквизиты.Найти(ЭлементМассива);
		
		Если ПорядковыйНомер <> Неопределено Тогда
			ПроверяемыеРеквизиты.Удалить(ПорядковыйНомер);
		КонецЕсли;
	КонецЦикла;	
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции работы с ресурсами внешних компонент

// Создает новое фоновое задание
//
// Параметры:
//  ИмяМетода	 - Строка	 - имя метода фонового задания
//  Параметры	 - Массив	 - массив параметров метода фонового задания
//  Наименование - Строка	 - наименование фонового задания
//  Ключ		 - Строка	 - ключ фонового задания
// 
// Возвращаемое значение:
//  Структура - идентификатор фонового задания или описание ошибки
//	*Идентификатор	 - УникальныйИдентификатор	 - идентификатор фонового задания
//	*ОписаниеОшибки	 - Строка	 - описание ошибки в случае неудачного запуска
//
Функция СоздатьФоновоеЗадание(Знач ИмяМетода, Знач Параметры = Неопределено, Знач Наименование = "", Знач Ключ = "") Экспорт
	
	Результат = Новый Структура("Идентификатор, ОписаниеОшибки", Неопределено, "");
	
	// Проверка обязательных параметров для запуска фонового задания
	Если Параметры <> Неопределено И ТипЗнч(Параметры) <> Тип("Массив") Тогда
		Результат.ОписаниеОшибки = "Неверно задан тип контейнера параметров для фонового задания.";
		Возврат Результат;
	КонецЕсли;
	
	ПараметрыЗапуска = Новый Массив;
	ПараметрыЗапуска.Добавить(ИмяМетода);
	ПараметрыЗапуска.Добавить(Параметры);
	
	Если ПустаяСтрока(Ключ) Тогда
		Ключ = Строка(Новый УникальныйИдентификатор);
	КонецЕсли;
	
	Отбор = Новый Структура("Ключ, Состояние", Ключ, СостояниеФоновогоЗадания.Активно);
	АктивныеФоновыеЗадания = ФоновыеЗадания.ПолучитьФоновыеЗадания(Отбор);
	
	Если АктивныеФоновыеЗадания.Количество() = 0 Тогда	
		ФоновоеЗадание = ФоновыеЗадания.Выполнить("ОбщегоНазначения.ВыполнитьМетодКонфигурации", 
			ПараметрыЗапуска, Ключ, Наименование);
			
		Результат.Идентификатор = ФоновоеЗадание.УникальныйИдентификатор;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Создает новое фоновое задание
//
// Параметры:
//  ИмяМетода	 - Строка	 - имя метода фонового задания
//  Параметры	 - Массив	 - массив параметров метода фонового задания
//  Наименование - Строка	 - наименование фонового задания
//  Ключ		 - Строка	 - ключ фонового задания
// 
// Возвращаемое значение:
//  Структура - идентификатор фонового задания или описание ошибки
//	*Идентификатор	 - УникальныйИдентификатор	 - идентификатор фонового задания
//	*ОписаниеОшибки	 - Строка	 - описание ошибки в случае неудачного запуска
//
Процедура СоздатьФоновоеЗаданиеДляОтчета(Знач ИмяМетода, Знач Параметры = Неопределено, Наименование = "") Экспорт
	
	ПараметрыЗапуска = Новый Массив;
	ПараметрыЗапуска.Добавить(ИмяМетода);
	ПараметрыЗапуска.Добавить(Параметры);
	
	Отбор = Новый Структура("Наименование, Состояние", Наименование, СостояниеФоновогоЗадания.Активно);
	АктивныеФоновыеЗадания = ФоновыеЗадания.ПолучитьФоновыеЗадания(Отбор);
	
	Если АктивныеФоновыеЗадания.Количество() > 0 Тогда	
		Для Каждого Задание Из АктивныеФоновыеЗадания Цикл
			Задание.Отменить();
		КонецЦикла;
	КонецЕсли;
	
	ФоновоеЗадание = ФоновыеЗадания.Выполнить("ОбщегоНазначения.ВыполнитьМетодКонфигурации", ПараметрыЗапуска, , Наименование);
	
КонецПроцедуры

// Функция - Получить идентификатор объекта
//
// Параметры:
//  ПолноеИмяФормы - Строка - Полное имя формы
// 
// Возвращаемое значение:
//  СправочникСсылка.ИдентификаторыОбъектовМетаданных - ссылка на соответствующий форме элемент справочник.
//  Если элемента нет возвращается Неопределено
//
Функция ПолучитьИдентификаторОбъекта(Знач ПолноеИмяФормы) Экспорт
	
	Результат = Неопределено;
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ИдентификаторыОбъектовМетаданных.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.ИдентификаторыОбъектовМетаданных КАК ИдентификаторыОбъектовМетаданных
	|ГДЕ
	|	ИдентификаторыОбъектовМетаданных.ПолноеИмяФормы = &ПолноеИмяФормы
	|	И НЕ ИдентификаторыОбъектовМетаданных.ПометкаУдаления";
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("ПолноеИмяФормы", ПолноеИмяФормы);
	
	РезультатЗапроса = Запрос.Выполнить();
	Если НЕ РезультатЗапроса.Пустой() Тогда
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Результат = Выборка.Ссылка;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает шаблон ссылки на объект.
// <!-- sdms_link_prefix --> нужно заменить взависимости от необходимости получения ссылки для тонкого или веб клиента
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - ссылка на объект ИБ.
//
// Возвращаемое значение:
//  Строка.
//
Функция ПолучитьШаблонНавигационнойСсылки(Знач Ссылка) Экспорт
	
	Если ЗначениеЗаполнено(Ссылка) Тогда
		Результат = СтрШаблон("<!-- sdms_link_prefix -->#%1", ПолучитьНавигационнуюСсылку(Ссылка));
	Иначе
		Результат = "";
	КонецЕсли;
	
	Возврат Результат;	
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Построитель запроса

// Добавляет элемент отбора в построитель запроса
//
// Параметры:
//  ПостроительЗапроса  - объект ПостроительЗапроса
//  Описание  - Строка - Описание элемента отбора в виде наименования доступного поля
//  ВидСравнения  - ВидСравнения - Содержит способ сравнения, используемый при фильтрации по элементу отбора.
//  Значение  - Произвольный - Содержит значение, по которому будет осуществляться фильтрация.
//
Процедура ПостроительЗапросаУстановитьОтбор(ПостроительЗапроса, Знач Описание, Знач ВидСравнения, Знач Значение) Экспорт
	
	Отбор = ПостроительЗапроса.Отбор.Добавить(Описание);
	Отбор.ВидСравнения = ВидСравнения;
	Отбор.Значение = Значение;	
	Отбор.Использование = Истина;
	
КонецПроцедуры

#Область ОбработчикиПодпискиНаСобытия

Процедура ОбработкаПолученияФормы(Источник, ВидФормы, Параметры, ВыбраннаяФорма, ДополнительнаяИнформация, СтандартнаяОбработка) Экспорт
	
	ТипИсточника = ТипЗнч(Источник);
	ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипИсточника);
	ЭтоОсновнаяФорма = Ложь;
	
	Если ВидФормы = "ФормаНастроек" Тогда
		ОсновнаяФорма = ОбъектМетаданных.ОсновнаяФормаНастроек;
	ИначеЕсли  ВидФормы = "ФормаВарианта" Тогда
		ОсновнаяФорма = ОбъектМетаданных.ОсновнаяФормаВарианта
	Иначе
		ОсновнаяФорма = ОбъектМетаданных.ОсновнаяФорма;
		ЭтоОсновнаяФорма = Истина;
	КонецЕсли;
	
	Если ОсновнаяФорма <> Неопределено Тогда  
		Если Параметры.Свойство("Функциональность") И Параметры.Свойство("ИмяФормы") Тогда 
			РегистрыСведений.ОтслеживаниеИспользованияФункциональности.Добавить(Параметры.Функциональность, Параметры.ИмяФормы);		
		Иначе
			РегистрыСведений.ОтслеживаниеИспользованияФункциональности.ОткрытиеФормы(ОсновнаяФорма.ПолноеИмя());
		КонецЕсли;
	ИначеЕсли ЭтоОсновнаяФорма Тогда
		Комментарий = СтрШаблон("Не установлена %1 для объекта ""%2""", ВидФормы, ОбъектМетаданных.ПолноеИмя());
		ЗаписьЖурналаРегистрации("ОбработкаПолученияФормы", УровеньЖурналаРегистрации.Ошибка, , , Комментарий);
	КонецЕсли;	
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

////////////////////////////////////////////////////////////////////////////////
// Служебные процедуры и функции работы с внешними компонентами

// Создает экземпляр внешней компоненты. Если не удалось создать внешнюю компоненту
//  вызывается исключение.
//
// Параметры:
//  Местоположение	 - Строка	 - Местоположение внешнего компонента. См. Синтакс-помощник - ПодключитьВнешнююКомпоненту()
//  Имя				 - Строка	 - Символическое имя подключаемой внешнего компонента
//  ProgID			 - Строка	 - Идентификатор объекта внешнего компонента в
//									виде ProgID (Programmatic Identifier) реестра MS Windows (например: "AddIn.Scanner").
//  Тип				 - ТипВнешнейКомпоненты	 - тип внешней компоненты. По умолчанию - Native
// 
// Возвращаемое значение:
//  Экземпляр - внешней компоненты.
//
Функция ИнициализироватьВнешнююКомпоненту(Знач Местоположение, Знач Имя, Знач ProgID, Знач Тип = Неопределено)
	
	Если Тип = Неопределено Тогда
		Тип = ТипВнешнейКомпоненты.Native;
	КонецЕсли;
	
	// Подключение внешней компоненты
	Подключена = ПодключитьВнешнююКомпоненту(Местоположение, Имя, Тип);
		
	// Если платформе удалось подключить внешнюю компоненту, выполняется попытка создания
	// экземпляра.
	Если Подключена Тогда
		Попытка
			ВнешняяКомпонента = Новый(ProgID);
			Подключена = (ВнешняяКомпонента <> Неопределено);
		Исключение
			Подключена = Ложь;
		КонецПопытки;
	КонецЕсли;
	
	// Если компоненту не удалось подключить или при создании экземпляра компоненты возникла
	// ошибка, необходимо прервать исполнение кода, чтобы не начал исполняться без приостановки.
	Если НЕ Подключена Тогда
		ВызватьИсключение "Ошибка создания экземпляра внешней компоненты """ + ProgID + """
			|" + ОписаниеОшибки();
	КонецЕсли;
	
	Возврат ВнешняяКомпонента;
	
КонецФункции

#КонецОбласти

Процедура ОтправитьОповещениеПользователям(Ссылка, Комментарий, Знач ИдентификаторКомментария,  
	Знач ДатаСозданияКомментария = Неопределено, Знач ОбщедоступныйКомментарий = Истина, Знач Инициатор = Неопределено) Экспорт
	
	РезультатЗапроса = РегистрыСведений.Участники.ПолучателиОповещения(Ссылка, Истина, Инициатор);
	Если НЕ ОбщедоступныйКомментарий Тогда
		ОтфильтроватьРезультатЗапросаПолучателей(РезультатЗапроса, Инициатор);
	КонецЕсли;
	
	Получатели = РезультатЗапроса.Выгрузить().ВыгрузитьКолонку("Пользователь");
	
	Если Получатели.Количество() > 0 Тогда
		// Добавим в регистр для пользователей сообщение
		СообщениеПользователям = Новый Структура;
		СообщениеПользователям.Вставить("ТекстСообщения", Комментарий);
		СообщениеПользователям.Вставить("КатегорияСообщения", Перечисления.КатегорииСообщенийПользователя.Комментарии);
		СообщениеПользователям.Вставить("Важность", Перечисления.ВажностьСообщения.Высокая);
		СообщениеПользователям.Вставить("ИдентификаторКомментария", ИдентификаторКомментария);
		СообщениеПользователям.Вставить("Период", ДатаСозданияКомментария);
		
		РегистрСведений = РегистрыСведений.ПодготовленныеСообщенияПользователяПоКатегориям;
		РегистрСведений.Добавить(Получатели, Ссылка, СообщениеПользователям, Инициатор);
		
		РегистрыСведений.НепросмотренныеКомментарии.ДобавитьНепросмотренные(Строка(ИдентификаторКомментария), Получатели);
	КонецЕсли;
	
КонецПроцедуры

// Получает на вход результат и накладывает фильтр по филиалу текущего пользователя. 
// Необходимо для того чтобы при снятии флага "Общедоступный" ограничить рассылку оповещений.
//
// Параметры:
//  РезультатЗапроса - РезультатЗапроса	 - результат запроса для передачи в модуль менеджера соответствующего объекта
//  АвторКомментария - СправочникСсылка.Пользователи	 - ссылка на автора комментария
//
Процедура ОтфильтроватьРезультатЗапросаПолучателей(РезультатЗапроса, АвторКомментария) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ВЫРАЗИТЬ(ЛичныеДелаСрезПоследних.Данные КАК Справочник.Филиалы) КАК Филиал
	|ПОМЕСТИТЬ ФилиалПользователя
	|ИЗ
	|	РегистрСведений.ЛичныеДела.СрезПоследних(
	|			&ТекущаяДата,
	|			Сотрудник = &Пользователь
	|				И Событие = ЗНАЧЕНИЕ(Перечисление.СобытияПоЛичнымДелам.ПереведенВДругоеПодразделение)) КАК ЛичныеДелаСрезПоследних
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Филиалы.Ссылка КАК Филиал,
	|	Филиалы.ТипФилиала КАК ТипФилиала
	|ИЗ
	|	ФилиалПользователя КАК ФилиалПользователя
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Филиалы КАК Филиалы
	|		ПО (Филиалы.Ссылка = ФилиалПользователя.Филиал)";
	
	Запрос.УстановитьПараметр("ТекущаяДата", ТекущаяДатаСеанса());
	Запрос.УстановитьПараметр("Пользователь", АвторКомментария);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	ПостроительЗапроса = Новый ПостроительЗапроса;
	ПостроительЗапроса.ИсточникДанных = Новый ОписаниеИсточникаДанных(РезультатЗапроса);
	
	Если Выборка.ТипФилиала <> Перечисления.ТипыФилиалов.НеIT Тогда
		НовыйОтбор = ПостроительЗапроса.Отбор.Добавить("ITФилиал");
		НовыйОтбор.ВидСравнения  = ВидСравнения.Равно;
		НовыйОтбор.Значение      = Истина;
		НовыйОтбор.Использование = Истина;
	Иначе
		НовыйОтбор = ПостроительЗапроса.Отбор.Добавить("Филиал");
		НовыйОтбор.ВидСравнения  = ВидСравнения.Равно;
		НовыйОтбор.Значение      = Выборка.Филиал;
		НовыйОтбор.Использование = Истина;
	КонецЕсли;
	
	ПостроительЗапроса.Выполнить();
	
	РезультатЗапроса = ПостроительЗапроса.Результат;
	
КонецПроцедуры

Процедура ИзменитьДоступностьПрограммногоЭлементаФормы(Знач Форма, Знач ИмяЭлемента, Знач Ссылка) Экспорт
	
	ИмяЭлемента  = ИмяЭлемента + СтрЗаменить(Форма.УникальныйИдентификатор, "-", "");
	ЭлементФормы = Форма.Элементы.Найти(ИмяЭлемента);
	
	Если ЭлементФормы <> Неопределено Тогда
		ЭлементФормы.Доступность = НЕ Ссылка.Пустая();
		
		Если СтрНачинаетсяС(ИмяЭлемента, "СтраницаПрикрепленныеФайлы") Тогда
			ЭлементФормы.Заголовок = ПанельНавигацииВызовСервера.ЗаголовокВкладкиПрикрепленныеФайлы(Ссылка);
		КонецЕсли;
		
		Если СтрНачинаетсяС(ИмяЭлемента, "СтраницаКомментарии_") Тогда
			ЭлементФормы.Заголовок = ПанельНавигацииВызовСервера.ЗаголовокВкладкиКомментарии(Ссылка);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Добавляет условное оформления таблицы по сроку реализации
//
// Параметры:
//  Форма - Управляемая форма - форма, в которой добавляется оформление
//  ОформляемыеТаблицы - Массив - массив структура с описанием оформляемых таблиц 
//
Процедура НастроитьПодсветкуПриПриближенииСрокаРеализации(Форма, Знач ОформляемыеТаблицы) Экспорт
	
	Филиал = ПараметрыСеанса.Филиал;
	Настройка = ПланыВидовХарактеристик.ВидыНастроекФилиалов.ПодсвечиватьПриПриближенииСрокаРеализации;
	Подсвечивать = РегистрыСведений.НастройкиФилиалов.ЗначениеНастройки(Филиал, Настройка);
	
	Если Подсвечивать Тогда
		Настройка = ПланыВидовХарактеристик.ВидыНастроекФилиалов.КоличествоДнейДоСрокаРеализации;
		КоличествоДней = РегистрыСведений.НастройкиФилиалов.ЗначениеНастройки(Филиал, Настройка);
		
		СекундВДне = 86400;
		ДатаОкончанияПодсветки = ТекущаяДатаСеанса() + (КоличествоДней * СекундВДне);
		
		Для Каждого Таблица Из ОформляемыеТаблицы Цикл	
			ЭлементОформления = Форма.УсловноеОформление.Элементы.Добавить();
			
			// Оформление
			ЖирныйШрифт = Новый Шрифт(ШрифтыСтиля.ОбычныйШрифтТекста, , , Истина);
			
			ЭлементОформления.Оформление.УстановитьЗначениеПараметра("Шрифт", ЖирныйШрифт);
			ЭлементОформления.Оформление.УстановитьЗначениеПараметра("ЦветФона", ЦветаСтиля.ЦветПодсказкиОбязательногоПоля);
			
			// Условие
			ГруппаОтбора = ЭлементОформления.Отбор.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
			ГруппаОтбора.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ;
			
			ИмяПоля = СтрШаблон("%1.СрокРеализации", Таблица.ИмяРеквизита);
			ПолеКомпоновки = Новый ПолеКомпоновкиДанных(ИмяПоля);
			
			ЭлементОтбора = ГруппаОтбора.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
			ЭлементОтбора.ЛевоеЗначение = ПолеКомпоновки;
			ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Заполнено;
			
			ЭлементОтбора = ГруппаОтбора.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
			ЭлементОтбора.ЛевоеЗначение = ПолеКомпоновки;
			ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.МеньшеИлиРавно;
			ЭлементОтбора.ПравоеЗначение = ДатаОкончанияПодсветки;
			
			Если Таблица.ЭтоДерево Тогда
				ИмяПоляГруппы = СтрШаблон("%1.ЭтоГруппа", Таблица.ИмяРеквизита);
				ЭлементОтбора = ГруппаОтбора.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
				ЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоляГруппы);
				ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
				ЭлементОтбора.ПравоеЗначение = Ложь;
			КонецЕсли;
			
			// Оформляемые поля
			ОформляемоеПоле = ЭлементОформления.Поля.Элементы.Добавить();
			ОформляемоеПоле.Поле = Новый ПолеКомпоновкиДанных(Таблица.ИмяЭлемента);
		КонецЦикла;
	КонецЕсли;
					
КонецПроцедуры

// Возвращает структуру со свойствами оформляемой таблицы формы
//
// Параметры:
//  ИмяЭлемента  - Строка - имя элемента формы таблицы
//  ИмяРеквизита - Строка - имя реквизита таблицы
//  ЭтоДерево    - Булево - Истина, если реквизит дерево значений, иначе таблица.
//
// Возвращаемое значение:
//   Структура   - структуру со свойствами оформляемой таблицы формы
//
Функция ОписаниеОформляемойТаблицыФормы(Знач ИмяЭлемента, Знач ИмяРеквизита, Знач ЭтоДерево = Истина) Экспорт
	
	ОписаниеТаблицы = Новый Структура;
	ОписаниеТаблицы.Вставить("ИмяЭлемента", ИмяЭлемента);
	ОписаниеТаблицы.Вставить("ИмяРеквизита", ИмяРеквизита);
	ОписаниеТаблицы.Вставить("ЭтоДерево", ЭтоДерево);

	Возврат ОписаниеТаблицы;

КонецФункции

#Область ФиксацияСостоянияОбъекта

#Область ПрограммныйИнтерфейс

// Получает из базы состояние проверяемых реквизитов и табличных частей объекта и записывает их в структуру
//
// Параметры:
//  Ссылка	 - Составной тип	 - объект. Может быть значением следующих типов: ДокументОбъект.ВнутреннееЗадание,
//   СправочникОбъект.Проекты, ДокументОбъект.Задача, ДокументОбъект.ЗаявкаНаРазработку, СправочникОбъект.Знания, Справочник.Продукты
// 
// Возвращаемое значение:
//   - Структура
//		* ЭтоНовый	 - Булево	 - признак того что объект является новым
//		* Значения	 - Структура	 - структура значений реквизитов и табличных частей объекта
//			** Реквизиты	 - Структура	 - значения проверяемых реквизитов объекта
//				*** <ключ элемента структуры>	 - Строка	 - имя реквизита
//				*** <значение элемента структуры>	 - Произвольный	 - значение реквизита
//			** ТабличныеЧасти	 - Структура	 - содержимое табличных частей объектов
//				*** <ключ элемента структуры>	 - Строка	 - имя табличной части
//				*** <значение элемента структуры>	 - Структура	 - проверяемые значения табличной части
//					**** Данные	 - ТаблицаЗначений	 - таблица с одной колонкой содержащей значения проверяемой колонки табличной части
//					**** ИмяПоля	 - Строка	 - имя проверяемой колонки
//
Функция ПолучитьСостояниеОбъектаДоЗаписи(Знач Ссылка) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ЭтоНовый", Ссылка.Пустая());
	Результат.Вставить("Значения", Новый Структура("Реквизиты, ТабличныеЧасти, ДопРеквизиты", 
		Новый Структура, Новый Структура, Новый Структура));
	
	// Проверяем реквизиты и табличные части объекта
	ПроверяемыеДанные = МенеджерОбъектаПоСсылке(Ссылка).ПроверяемыеСвойстваОбъекта();
	
	Если ПроверяемыеДанные.Реквизиты.Количество() > 0 Тогда
		СтрокаРеквизитов = СтрСоединить(ПроверяемыеДанные.Реквизиты, ",");
		
		// Реализация метода ЗначенияРеквизитовОбъекта() не позволяет
		// использовать её если ссылка на объект является пустой. Для
		// этого случая мы будем создавать структуру с реквизитами, а
		// в качестве значения реквизита будет выступать Неопределено
		
		Если НЕ Результат.ЭтоНовый Тогда
			Результат.Значения.Реквизиты = ЗначенияРеквизитовОбъекта(Ссылка, СтрокаРеквизитов);
		Иначе
			Результат.Значения.Реквизиты = Новый Структура(СтрокаРеквизитов);
		КонецЕсли;
	КонецЕсли;
	
	Если ПроверяемыеДанные.ТабличныеЧасти.Количество() > 0 Тогда
		// Реализация метода ПолучитьЗначенияТабличныхЧастей() позволяет
		// получить таблицу значений независимо от заполненности ссылки.
		Результат.Значения.ТабличныеЧасти = ПолучитьЗначенияТабличныхЧастей(Ссылка, ПроверяемыеДанные.ТабличныеЧасти);
	КонецЕсли;
	
	Результат.Значения.ДопРеквизиты = ПолучитьЗначенияСохраняемыхДопРеквизитов(Ссылка);
	
	Возврат Результат;
	
КонецФункции

// Прозводит сравнение реквизитов и табличных частей объекта после записи
//
// Параметры:
//  Объект			 - Составной тип	 - объект. Может быть значением следующих типов: ДокументОбъект.ВнутреннееЗадание,
//   СправочникОбъект.Проекты, ДокументОбъект.Задача, ДокументОбъект.ЗаявкаНаРазработку, СправочникОбъект.Знания, Справочник.Продукты
//  ЗначенияДоЗаписи - Структура	 - результат функции ПолучитьСостояниеОбъектаДоЗаписи()
//		* ЭтоНовый	 - Булево	 - признак того что объект является новым
//		* Значения	 - Структура	 - структура значений реквизитов и табличных частей объекта
//			** Реквизиты	 - Структура	 - значения проверяемых реквизитов объекта
//				*** <ключ элемента структуры>	 - Строка	 - имя реквизита
//				*** <значение элемента структуры>	 - Произвольный	 - значение реквизита
//			** ТабличныеЧасти	 - Структура	 - содержимое табличных частей объектов
//				*** <ключ элемента структуры>	 - Строка	 - имя табличной части
//				*** <значение элемента структуры>	 - Структура	 - проверяемые значения табличной части
//					**** Данные	 - ТаблицаЗначений	 - таблица с одной колонкой содержащей значения проверяемой колонки табличной части
//					**** ИмяПоля	 - Строка	 - имя проверяемой колонки
//  Комментарий		 - Структура, Неопределено	 - комментарий при смене статуса. Неопределено - комментарий не заполнен 
//	Различные		 - Булево - Признак того, что нужно смотреть не все записи, а только уникальные
//
Процедура ОбработатьИзменениеОбъекта(Знач Объект, Знач ЗначенияДоЗаписи, Знач ДопРеквизиты = Неопределено, Знач Комментарий = Неопределено, Различные = Ложь) Экспорт
	
	ТипОбъекта = ТипЗнч(Объект.Ссылка);
	
	Результат = Новый Структура;
	Результат.Вставить("ЭтоНовый", ЗначенияДоЗаписи.ЭтоНовый);
	Результат.Вставить("Реквизиты", Новый Структура);
	Результат.Вставить("ТабличныеЧасти", Новый Структура);
	Результат.Вставить("ДопРеквизиты", Новый Структура);
	Результат.Вставить("Комментарий", Комментарий);
	
	Если ТипОбъекта = Тип("ДокументСсылка.Задача") Тогда   
		Результат.Вставить("ОписаниеИзменилось", ЗначенияДоЗаписи.ОписаниеИзменилось);
		
		Если ЗначенияДоЗаписи.Свойство("ИзмененоПримечаниеРазработчиков") Тогда
			Результат.Вставить("ИзмененоПримечаниеРазработчиков", ЗначенияДоЗаписи.ИзмененоПримечаниеРазработчиков);
		КонецЕсли;
		
		Если ЗначенияДоЗаписи.Свойство("ИзмененоПримечаниеТестировщиков") Тогда
			Результат.Вставить("ИзмененоПримечаниеТестировщиков", ЗначенияДоЗаписи.ИзмененоПримечаниеТестировщиков);
		КонецЕсли;
	КонецЕсли;
	
	ИнтеграцияДополнительныхПодсистем.ДополнитьРезультатИзменениеОбъекта(Объект, ЗначенияДоЗаписи, Результат);
	
	// Сравнение реквизитов
	Для Каждого Элемент Из ЗначенияДоЗаписи.Значения.Реквизиты Цикл
		Если Элемент.Ключ <> "ОценкаТрудозатрат"
			И Элемент.Ключ <> "ОценкаТрудозатратТестирования"
			И Элемент.Ключ <> "Спринт" 
			И Элемент.Ключ <> "ПланГабаритноеПланирование" Тогда
			
			// Если объект новый и значение реквизита объекта заполнено
			// ИЛИ объект существует и значения реквизитов до и после записи отличаются
			
			ЗначенияРазличаются = ((ЗначенияДоЗаписи.ЭтоНовый И ЗначениеЗаполнено(Объект[Элемент.Ключ]))
				ИЛИ (НЕ ЗначенияДоЗаписи.ЭтоНовый И Элемент.Значение <> Объект[Элемент.Ключ]));
			
			Если ЗначенияРазличаются Тогда
				ОписаниеИзменения = Новый Структура;
				ОписаниеИзменения.Вставить("СтароеЗначение", Элемент.Значение);
				ОписаниеИзменения.Вставить("НовоеЗначение", Объект[Элемент.Ключ]);
				
				Результат.Реквизиты.Вставить(Элемент.Ключ, ОписаниеИзменения);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	// обработка изменения доп. реквизитов
	Если ТипЗнч(ДопРеквизиты) = Тип("ТаблицаЗначений") Тогда		
		Для Каждого ДопРеквизит Из ЗначенияДоЗаписи.Значения.ДопРеквизиты Цикл	
			Строка = ДопРеквизиты.Найти(Допреквизит.Ключ, "ИмяПредопределенныхДанных");
				
			Если Строка <> Неопределено И ДопРеквизит.Значение <> Строка.Значение Тогда
				ОписаниеИзменения = Новый Структура;
				ОписаниеИзменения.Вставить("СтароеЗначение", ДопРеквизит.Значение);
				ОписаниеИзменения.Вставить("НовоеЗначение", Строка.Значение);
					
				Результат.ДопРеквизиты.Вставить(ДопРеквизит.Ключ, ОписаниеИзменения);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;	
	
	// Обработка изменения спринта у задачи (уже проверенные значения)
	Если ЗначенияДоЗаписи.Значения.Реквизиты.Свойство("Спринт") Тогда
		СпринтДоЗаписи = ЗначенияДоЗаписи.Значения.Реквизиты.Спринт;
		ОписаниеИзменения = Новый Структура;
		ОписаниеИзменения.Вставить("СтароеЗначение", СпринтДоЗаписи.СтарыйСпринт);
		ОписаниеИзменения.Вставить("НовоеЗначение", СпринтДоЗаписи.НовыйСпринт);
		Результат.Реквизиты.Вставить("Спринт", ОписаниеИзменения);
	КонецЕсли;
	
	// Обработка изменения трудозатрат задачи	
	Если ТипОбъекта = Тип("ДокументСсылка.Задача") Тогда
		Если ЗначенияДоЗаписи.Значения.Реквизиты.Свойство("ОценкаТрудозатрат") Тогда
			ПредыдущееЗначение = УчетТрудозатрат.ПолучитьПлановыеТрудозатраты(Объект.Ссылка);
			НовоеЗначение = ЗначенияДоЗаписи.Значения.Реквизиты.ОценкаТрудозатрат;
			
			Если ПредыдущееЗначение <> НовоеЗначение Тогда
				ОписаниеИзменения = Новый Структура;
				ОписаниеИзменения.Вставить("СтароеЗначение", ПредыдущееЗначение);
				ОписаниеИзменения.Вставить("НовоеЗначение", НовоеЗначение);
			
				Результат.Реквизиты.Вставить("ОценкаТрудозатрат", ОписаниеИзменения);
			КонецЕсли;
		КонецЕсли;
		Если ЗначенияДоЗаписи.Значения.Реквизиты.Свойство("ОценкаТрудозатратТестирования") Тогда
			ПредыдущееЗначение = УчетТрудозатрат.ПолучитьПлановыеТрудозатраты(Объект.Ссылка, Перечисления.ТипыТрудозатрат.Тестирование);
			НовоеЗначение = ЗначенияДоЗаписи.Значения.Реквизиты.ОценкаТрудозатратТестирования;
			
			Если ПредыдущееЗначение <> НовоеЗначение Тогда
				ОписаниеИзменения = Новый Структура;
				ОписаниеИзменения.Вставить("СтароеЗначение", ПредыдущееЗначение);
				ОписаниеИзменения.Вставить("НовоеЗначение", НовоеЗначение);
				
				Результат.Реквизиты.Вставить("ОценкаТрудозатратТестирования", ОписаниеИзменения);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли; 
	
	// Сравнение табличных частей
	Для Каждого Элемент Из ЗначенияДоЗаписи.Значения.ТабличныеЧасти Цикл
		РезультатСравнения = СравнитьТаблицыЗначений(Элемент.Значение, Объект[Элемент.Ключ], Различные);
		
		Если РезультатСравнения.ЕстьИзменения Тогда
			Результат.ТабличныеЧасти.Вставить(Элемент.Ключ, РезультатСравнения);
		КонецЕсли;
	КонецЦикла;
	
	Если Результат.ЭтоНовый 
		ИЛИ Результат.Реквизиты.Количество() > 0 
		ИЛИ Результат.ТабличныеЧасти.Количество() > 0 
		ИЛИ Результат.ДопРеквизиты.Количество() > 0 Тогда
		
		РегистрыСведений.ОчередьСобытийНаОбработку.ИзменениеОбъекта(Объект.Ссылка, Результат);
	Иначе
		ИнтеграцияДополнительныхПодсистем.ИзменениеОбъекта(Объект.Ссылка, Результат);
	КонецЕсли;
	
КонецПроцедуры
#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ПолучитьЗначенияСохраняемыхДопРеквизитов(Знач Ссылка)
	
	ДопРеквизиты = Новый Структура;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ВидыДополнительныхРеквизитов.Ссылка КАК Ссылка,
	|	ВидыДополнительныхРеквизитов.ИмяПредопределенныхДанных КАК Наименование,
	|	ЕСТЬNULL(ЗначенияДополнительныхРеквизитовОбъектов.Значение, НЕОПРЕДЕЛЕНО) КАК Значение
	|ИЗ
	|	ПланВидовХарактеристик.ВидыДополнительныхРеквизитов КАК ВидыДополнительныхРеквизитов
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ПланВидовХарактеристик.ВидыДополнительныхРеквизитов.ИспользоватьВОбъектах КАК ВидыДополнительныхРеквизитовИспользоватьВОбъектах
	|		ПО ВидыДополнительныхРеквизитов.Ссылка = ВидыДополнительныхРеквизитовИспользоватьВОбъектах.Ссылка
	|			И (ВидыДополнительныхРеквизитов.Проверяемый)
	|			И (ТИПЗНАЧЕНИЯ(ВидыДополнительныхРеквизитовИспользоватьВОбъектах.Тип) = ТИПЗНАЧЕНИЯ(&Ссылка))
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ЗначенияДополнительныхРеквизитовОбъектов КАК ЗначенияДополнительныхРеквизитовОбъектов
	|		ПО (ЗначенияДополнительныхРеквизитовОбъектов.Реквизит = ВидыДополнительныхРеквизитов.Ссылка)
	|			И (ЗначенияДополнительныхРеквизитовОбъектов.Объект = &Ссылка)";
	
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл		
		ДопРеквизиты.Вставить(Выборка.Наименование, Выборка.Значение);
	КонецЦикла;
	
	Возврат ДопРеквизиты;
	
КонецФункции

// Получает содержимое проверяемых колонок табличных частей объекта
//
// Параметры:
//  Ссылка			 - ДокументСсылка.ВнутреннееЗадание, СправочникСсылка.Проекты,
//						ДокументСсылка.Задача, ДокументСсылка.ЗаявкаНаРазработку, СправочникСсылка.Знания	 - ссылка на объект
//  ТабличныеЧасти	 - Структура	 - названия табличных частей и проверяемых колонок
//		* <ключ элемента структуры>	 - Строка	 - название проверяемой табличной части
//		* <значение элемента структуры>	 - Строка	 - название колонки, значения которой проверяются на изменение
// 
// Возвращаемое значение:
//   - Структура
//		* <ключ элемента структуры>	 - Строка	 - имя табличной части
//		* <значение элемента структуры>	 - Структура	 - проверяемые значения табличной части
//			** Данные	 - ТаблицаЗначений	 - таблица с одной колонкой содержащей значения проверяемой колонки табличной части
//			** ИмяПоля	 - Строка	 - имя проверяемой колонки
//
Функция ПолучитьЗначенияТабличныхЧастей(Знач Ссылка, Знач ТабличныеЧасти)
	
	ПолноеИмяМетаданных = Ссылка.Метаданные().ПолноеИмя();
	
	// Формирование массива с текстами пакетов запроса
	Пакеты = Новый Массив;
	Для Каждого ТабличнаяЧасть Из ТабличныеЧасти Цикл
		Поля = СтрСоединить(ТабличнаяЧасть.Значение.Поля, ",");
		
		ТекстЗапроса = 
		"ВЫБРАТЬ
		|	" + Поля + "
		|ИЗ
		|	" + ПолноеИмяМетаданных + "." + ТабличнаяЧасть.Ключ + "
		|ГДЕ
		|	Ссылка = &Ссылка";
		
		Пакеты.Добавить(ТекстЗапроса);
	КонецЦикла;
	
	Разделитель = 
	";
	|
	|////////////////////////////////////////////////////////////////////////////////
	|";
	
	// Сборка текста запроса и выполнение запроса
	Запрос = Новый Запрос;
	Запрос.Текст = СтрСоединить(Пакеты, Разделитель);
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	
	Пакеты = Запрос.ВыполнитьПакет();
	
	// Заполнение структуры значениями табличных частей
	Номер = 0;
	
	Для Каждого ТабличнаяЧасть Из ТабличныеЧасти Цикл
		Данные = ТабличнаяЧасть.Значение;
		// Не проверяем наличие данных в результатах запросов, так
		// как в результате всё равно будет таблица значений
		Таблица = Пакеты.Получить(Номер).Выгрузить();
		Данные.Вставить("Данные", Таблица);
		Номер = Номер + 1;
	КонецЦикла;
	
	Возврат ТабличныеЧасти;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область CodeReview

Функция ОпределитьКатегориюСообщения(Знач ИмяЭлемента) Экспорт
	
	МассивИменГлавныеСобытия = Новый Массив;
	МассивИменГлавныеСобытия.Добавить("Статус");
	МассивИменГлавныеСобытия.Добавить("Назначена");
	МассивИменГлавныеСобытия.Добавить("Описание");
	МассивИменГлавныеСобытия.Добавить("ФинальныйСтатус");
	МассивИменГлавныеСобытия.Добавить("НаборыЗнанийПоУровням");
	МассивИменГлавныеСобытия.Добавить("Рекомендовать");
	
	Возврат ?(МассивИменГлавныеСобытия.Найти(ИмяЭлемента) <> Неопределено, Перечисления.КатегорииСобытийИсторияИзменений.Главное, 
		Перечисления.КатегорииСобытийИсторияИзменений.Прочее);
	
КонецФункции

Функция ПолучитьСтруктуруДанныхДляЗаписиВИсторию(Знач СформироватьТаблицуЗначений = Истина) Экспорт
	
	Если СформироватьТаблицуЗначений Тогда
		ОписаниеТипа = Новый ОписаниеТипов("ПеречислениеСсылка.КатегорииСобытийИсторияИзменений");
		
		ДанныеДляЗаписиПользователю = Новый ТаблицаЗначений;
		ДанныеДляЗаписиПользователю.Колонки.Добавить("ТекстСообщения", Новый ОписаниеТипов("Строка"));
		ДанныеДляЗаписиПользователю.Колонки.Добавить("Данные", Новый ОписаниеТипов("Строка"));
		ДанныеДляЗаписиПользователю.Колонки.Добавить("Категория", ОписаниеТипа);
	Иначе
		ДанныеДляЗаписиПользователю = Новый Структура("ТекстСообщения, Данные, Категория");
	КонецЕсли;

	Возврат ДанныеДляЗаписиПользователю;
	
КонецФункции

// Сравнивает таблицы значений по ключевому полю и возвращает результат сравнения.
//  ВАЖНО! Если не было изменений по ключевому полю, результат сравнения будет иметь
//  признаки Добавлено и Удалено установленные в Истина.
//
// Параметры:
//  ДанныеТабличнойЧасти - Структура - содержит данные для сравнения и описание таблицы до записи
//  * Поля	 - Массив	 - имена всех колонок табличной части, изменение которых отслеживаются
//  * КлючевоеПоле	 - Строка	 - имя ключевого поля табличной части
//  * Данные	 - ТаблицаЗначений	 - данные табличной части до записи
//  НоваяТабличнаяЧасть	 - Структура - содержит данные для сравнения и описание таблицы после записи
//  * Поля	 - Массив	 - имена всех колонок табличной части, изменение которых отслеживаются
//  * КлючевоеПоле	 - Строка	 - имя ключевого поля табличной части
//  * Данные	 - ТаблицаЗначений	 - данные табличной части после записи
//  Различные - Булево - Флаг выбора только различных строк в таблицах
// 
// Возвращаемое значение:
//  Массив - результат сравнения таблиц значений по ключевому полю. Содержит структуры с описанием изменений
//  * КлючевоеПоле		 - Произволный	 - значение ключевого поля строки
//  * Добавлено			 - Булево		 - признак того, что строка с данным значением ключевого поля была добавлена
//  * Удалено			 - Булево		 - признак того, что строка с данным значением ключевого поля была удалена
//  * ИзмененныеЛанные	 - Массив		 - соедержит структуры с описанием изменений всех остальных полей таблицы
//  ** Поле			 - Строка		 - имя поля
//  ** СтароеЗначение	 - Произвольный	 - старое значение поля
//  ** НовоеЗначение	 - Произвольный	 - новое значение поля
//
Функция СравнитьТаблицыЗначений(Знач ДанныеТабличнойЧасти, Знач НоваяТабличнаяЧасть, Знач Различные = Ложь)
	
	Поля = ДанныеТабличнойЧасти.Поля;	
	НовоеЗначение = НоваяТабличнаяЧасть.Выгрузить(, СтрСоединить(Поля, ","));
	
	ШаблонЗапроса = 
	"ВЫБРАТЬ
	|	%1
	|ПОМЕСТИТЬ СтароеЗначение
	|ИЗ
	|	&СтароеЗначение КАК СтарыеЗначения
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	%2
	|ПОМЕСТИТЬ НовоеЗначение
	|ИЗ
	|	&НовоеЗначение КАК НовыеЗначения
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ %7
	|	%1
	|ПОМЕСТИТЬ Удаленные
	|ИЗ
	|	СтароеЗначение КАК СтарыеЗначения
	|		ЛЕВОЕ СОЕДИНЕНИЕ НовоеЗначение КАК НовыеЗначения
	|		ПО %3
	|ГДЕ
	|	НовыеЗначения.%5 ЕСТЬ NULL
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ %7
	|	%2
	|ПОМЕСТИТЬ Новые
	|ИЗ
	|	НовоеЗначение КАК НовыеЗначения
	|		ЛЕВОЕ СОЕДИНЕНИЕ СтароеЗначение КАК СтарыеЗначения
	|		ПО %4
	|ГДЕ
	|	СтарыеЗначения.%5 ЕСТЬ NULL
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ЕСТЬNULL(Удаленные.%5, Новые.%5) КАК %5,
	|	Новые.%5 ЕСТЬ NULL КАК Удалено,
	|	Удаленные.%5 ЕСТЬ NULL КАК Добавлено
	|	%6
	|ИЗ
	|	Удаленные КАК Удаленные
	|		ПОЛНОЕ СОЕДИНЕНИЕ Новые КАК Новые
	|		ПО Удаленные.%5 = Новые.%5";
	
	МассивСтарыхЗначений = Новый Массив;
	МассивНовыхЗначений = Новый Массив;
	МассивУсловийСтарогоСоединения = Новый Массив;
	МассивУсловийНовогоСоединения = Новый Массив;
	МассивПроверяемыхПолей = Новый Массив;
	
	ШаблонСтарогоЗначения = "СтарыеЗначения.%1 КАК %1";
	ШаблонНовогоЗначения = "НовыеЗначения.%1 КАК %1";
	ШаблонУсловияСтарогоСоединения = "СтарыеЗначения.%1 = НовыеЗначения.%1";
	ШаблонУсловияНовогоСоединения = "НовыеЗначения.%1 = СтарыеЗначения.%1";
	ШаблонПроверяемогоПоля = 
	"Удаленные.%1 КАК Старая_%1,
	|	Новые.%1 КАК Новая_%1";
	
	Для Каждого Поле Из Поля Цикл
		СтрокаСтарогоЗначения = СтрШаблон(ШаблонСтарогоЗначения, Поле);
		СтрокаНовогоЗначения = СтрШаблон(ШаблонНовогоЗначения, Поле);
		
		МассивСтарыхЗначений.Добавить(СтрокаСтарогоЗначения);
		МассивНовыхЗначений.Добавить(СтрокаНовогоЗначения);
		
		СтрокаУсловияСтарогоСоединения = СтрШаблон(ШаблонУсловияСтарогоСоединения, Поле);
		СтрокаУсловияНовогоСоединения = СтрШаблон(ШаблонУсловияНовогоСоединения, Поле);
		
		МассивУсловийСтарогоСоединения.Добавить(СтрокаУсловияСтарогоСоединения);
		МассивУсловийНовогоСоединения.Добавить(СтрокаУсловияНовогоСоединения);
		
		Если Поле <> ДанныеТабличнойЧасти.КлючевоеПоле Тогда
			СтрокаПроверяемогоПоля = СтрШаблон(ШаблонПроверяемогоПоля, Поле);
			МассивПроверяемыхПолей.Добавить(СтрокаПроверяемогоПоля);
		КонецЕсли;
	КонецЦикла;
	
	ПоляСтарыхЗначений = СтрСоединить(МассивСтарыхЗначений, ",");
	ПоляНовыхЗначений = СтрСоединить(МассивНовыхЗначений, ",");
	УсловияСтарогоЗапроса = СтрСоединить(МассивУсловийСтарогоСоединения, " И ");
	УсловияНовогоЗапроса = СтрСоединить(МассивУсловийНовогоСоединения, " И ");
	
	ПроверяемыеПоля = "";
	
	Если МассивПроверяемыхПолей.Количество() > 0 Тогда
		ПроверяемыеПоля = СтрШаблон(",%1", СтрСоединить(МассивПроверяемыхПолей, ","));
	КонецЕсли;
	
	ТекстЗапроса = СтрШаблон(ШаблонЗапроса, ПоляСтарыхЗначений, ПоляНовыхЗначений, УсловияСтарогоЗапроса,
		УсловияНовогоЗапроса, ДанныеТабличнойЧасти.КлючевоеПоле, ПроверяемыеПоля, ?(Различные, "РАЗЛИЧНЫЕ", ""));
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	
	Запрос.УстановитьПараметр("СтароеЗначение", ДанныеТабличнойЧасти.Данные);
	Запрос.УстановитьПараметр("НовоеЗначение", НовоеЗначение);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	РезультатСравнения = Новый Структура();
	РезультатСравнения.Вставить("Добавлено", Новый Массив);
	РезультатСравнения.Вставить("Удалено", Новый Массив);
	РезультатСравнения.Вставить("Изменено", Новый Массив);
	РезультатСравнения.Вставить("ЕстьИзменения", Ложь);
	
	// Есть один нюанс. При сравнении данных новой и старой таблицы
	// если не было изменений по ключевому полю, результат сравнения
	// будет содержать признаки Удалено и Добавлено, установленные в
	// значения Истина.
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		РезультатСравнения.ЕстьИзменения = Истина;
		
		Выборка = РезультатЗапроса.Выбрать();
		Поля.Удалить(Поля.Найти(ДанныеТабличнойЧасти.КлючевоеПоле));
		
		Пока Выборка.Следующий() Цикл
			СтруктураИзменения = Новый Структура;
			СтруктураИзменения.Вставить("КлючевоеПоле", ДанныеТабличнойЧасти.КлючевоеПоле);
			СтруктураИзменения.Вставить("ЗначениеКлючевогоПоля", Выборка[ДанныеТабличнойЧасти.КлючевоеПоле]);
			
			ИзмененныеДанные = Новый Массив;
			Для Каждого Поле Из Поля Цикл       
				СтруктураИзмененныхДанных = Новый Структура;
				СтруктураИзмененныхДанных.Вставить("Поле", Поле);
				СтруктураИзмененныхДанных.Вставить("СтароеЗначение", Выборка["Старая_" + Поле]);
				СтруктураИзмененныхДанных.Вставить("НовоеЗначение", Выборка["Новая_" + Поле]);
				
				ИзмененныеДанные.Добавить(СтруктураИзмененныхДанных);
			КонецЦикла;
			
			СтруктураИзменения.Вставить("ИзмененныеДанные", ИзмененныеДанные);
			
			Если Выборка.Добавлено Тогда
				РезультатСравнения.Добавлено.Добавить(СтруктураИзменения);
			ИначеЕсли Выборка.Удалено Тогда
				РезультатСравнения.Удалено.Добавить(СтруктураИзменения);
			Иначе
				РезультатСравнения.Изменено.Добавить(СтруктураИзменения);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат РезультатСравнения;
	
КонецФункции

// Формирует структуру с полями
//
// Параметры:
//  Имя				 - Строка	 - имя поля
//  Синоним			 - Строка	 - синоним поля
//  СтароеЗначение	 - Произвольный	 - старое значение
//  НовоеЗначение	 - Произвольный	 - новое значения
//  Детализация		 - Булево	 - признак вывода различий
// 
// Возвращаемое значение:
//  Структура - описание поля
//
Функция СвойстваПоля(Знач Имя, Знач Синоним, СтароеЗначение = Неопределено,
	НовоеЗначение = Неопределено, Детализация = Истина) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Имя", Имя);
	Результат.Вставить("Синоним", Синоним);
	Результат.Вставить("СтароеЗначение", СтароеЗначение);
	Результат.Вставить("НовоеЗначение", НовоеЗначение);
	Результат.Вставить("ВыводитьРазличия", Детализация);
	
	Возврат Результат;
	
КонецФункции

// Возвращает роль пользователя в направлении
//
// Параметры:
//  Направление	 - СправочникСсылка.НаправленияРазработки - направление
//  Пользователь - СправочникСсылка.Пользователи	 - пользователь
// 
// Возвращаемое значение:
//  СправочникСсылка.РолиПользователей, Неопределено - роль пользователя по направлению
//
Функция РольПользователяВНаправлении(Направление, Знач Пользователь = Неопределено) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	РолиПользователейПоНаправлениям.Роль КАК Роль
	|ИЗ
	|	РегистрСведений.РолиПользователейПоНаправлениям КАК РолиПользователейПоНаправлениям
	|ГДЕ
	|	РолиПользователейПоНаправлениям.НаправлениеРазработки = &Направление
	|	И РолиПользователейПоНаправлениям.Пользователь = &Пользователь";
	
	Запрос.УстановитьПараметр("Направление", Направление);
	Запрос.УстановитьПараметр("Пользователь", ?(ЗначениеЗаполнено(Пользователь), Пользователь, ПараметрыСеанса.ТекущийПользователь));
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		РольПользователя = Выборка.Роль;
	Иначе
		РольПользователя = Неопределено;
	КонецЕсли;
	
	Возврат РольПользователя;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ФОРМАТИРОВАННЫЕ ДОКУМЕНТЫ

// Функция возвращает область текста, обрамленную конструкциями #Область <ИмяОбласти>#
//  #КонецОбласти <ИмяОбласти>#.
//
// Параметры:
//  Шаблон					 - Строка	 - текст шаблона
//  ИмяОбласти				 - Строка	 - имя области шаблона, cодержимое которой нужно получить
//  ОбязательныйРаздел		 - Булево	 - определяет необходимость изменения в заголовке раздела признака {ПризнакНеобязательности}
//  ДобавитьПереносСтроки	 - Булево	 - признак необходимости добавления к результату символа переноса строки
// 
// Возвращаемое значение:
//  Строка - содержимое области шаблона
//
Функция ПолучитьСодержимоеОбластиШаблона(Знач Шаблон, Знач ИмяОбласти,
	Знач ОбязательныйРаздел = Истина, Знач ДобавитьПереносСтроки = Истина) Экспорт
	
	// Чтобы исключить регистрозависимость, переведем все данные для поиска в
	// верхний регистр.
	ШаблонНормализованный = ВРег(Шаблон);
	НачалоОбласти = ВРег(СтрШаблон("#Область %1#", ИмяОбласти));
	КонецОбласти  = ВРег(СтрШаблон("#КонецОбласти %1#", ИмяОбласти));
	
	// Получаем первый символ и количество символов в области
	ПозицияНачала      = СтрНайти(ШаблонНормализованный, НачалоОбласти) + СтрДлина(НачалоОбласти);
	КоличествоСимволов = СтрНайти(ШаблонНормализованный, КонецОбласти, , ПозицияНачала) - ПозицияНачала;
	
	// Получаем содержимое области из оригинального шаблона
	ОбластьШаблона = СокрЛП(Сред(Шаблон, ПозицияНачала, КоличествоСимволов));
	Если ДобавитьПереносСтроки Тогда
		ОбластьШаблона = ОбластьШаблона + Символы.ПС;
	КонецЕсли;
	
	// Теперь попробуем найти {ПризнакНеобязательности} и заменить его
	ПозицияНачала = СтрНайти(ВРег(ОбластьШаблона), ВРег("{ПризнакНеобязательности}"));
	Если ПозицияНачала > 0 Тогда
		ОбластьШаблона = СтрЗаменить(ОбластьШаблона, "{ПризнакНеобязательности}",
			?(ОбязательныйРаздел = Истина, "", " (необязательный раздел)"));
	КонецЕсли;
	
	Возврат СокрЛП(ОбластьШаблона);
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЧИЕ ПРОЦЕДУРЫ И ФУНКЦИИ

Функция ЕстьНезакрытыйПериодПриостановкиЗадачи(Знач Задача) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ПриостановленныеЗадачиСрезПоследних.ДатаОкончания КАК ДатаОкончания
	|ИЗ
	|	РегистрСведений.ПриостановленныеЗадачи.СрезПоследних(&Дата, Задача = &Задача) КАК ПриостановленныеЗадачиСрезПоследних
	|ГДЕ
	|	ПриостановленныеЗадачиСрезПоследних.ДатаОкончания = ДАТАВРЕМЯ(1, 1, 1)";
	
	Запрос.УстановитьПараметр("Дата", ТекущаяДатаСеанса());
	Запрос.УстановитьПараметр("Задача", Задача);
	
	Возврат НЕ Запрос.Выполнить().Пустой();
		
КонецФункции

Функция ПолучитьРабочееВремяДляРегистраСтатистики(Знач ДатаНачала, Знач ДатаОкончания, Знач ПроизводственныйКалендарь) Экспорт
	
	ТекущаяДата_НачалоДня = НачалоДня(ДатаНачала);
	НакопленныеМинуты = 0;
	НачалоРабочегоДня = 10;
	МинутВЧасе = 60;
	СекундВДне = 86400;
		
	// Перебираем все даты, начиная с даты начала по дату окончания.
	Пока ТекущаяДата_НачалоДня < ДатаОкончания Цикл
		
		СчитатьВремя = Истина;
		
		// Ищем текущую дату в производственном календаре - выходной или предпраздничный день.
		// Если день ненайден или найден рабочий день - то используем показатели для рабочего дня.
		
		НайденнаяСтрока = ПроизводственныйКалендарь.Найти(ТекущаяДата_НачалоДня, "Дата");
		РабочийДень = Перечисления.ВидыДнейПроизводственногоКалендаря.Рабочий;
		ПредпраздничныйДень = Перечисления.ВидыДнейПроизводственногоКалендаря.Предпраздничный;
		
		Если НайденнаяСтрока = Неопределено ИЛИ НайденнаяСтрока.ВидДня = РабочийДень Тогда
			КонецРабочегоДня = 19;
			НормаВремени = 480;
		ИначеЕсли НайденнаяСтрока.ВидДня = ПредпраздничныйДень Тогда
			КонецРабочегоДня = 18;
			НормаВремени = 420;
		Иначе
			ТекущаяДата_НачалоДня = ТекущаяДата_НачалоДня + СекундВДне;
			Продолжить;
		КонецЕсли;
		
		// Проверяем для даты начала, попадает ли она в промежуток рабочего дня.
		// Берем промежуток в минутах относительно 00:00
		Если День(ТекущаяДата_НачалоДня) = День(ДатаНачала) Тогда
			ЧасДатыНачала = Час(ДатаНачала);
			
			Если ЧасДатыНачала < НачалоРабочегоДня Тогда
				НачалоДня = НачалоРабочегоДня * МинутВЧасе;
			ИначеЕсли ЧасДатыНачала < КонецРабочегоДня Тогда
				НачалоДня = ЧасДатыНачала * МинутВЧасе + Минута(ДатаНачала);
			Иначе
				СчитатьВремя = Ложь;
			КонецЕсли;
		Иначе
			НачалоДня = НачалоРабочегоДня * МинутВЧасе;
		КонецЕсли;
		
		// Тоже самое для даты окончания.
		Если День(ТекущаяДата_НачалоДня) = День(ДатаОкончания) Тогда
			ЧасДатыОкончания = Час(ДатаОкончания);
			
			Если ЧасДатыОкончания > КонецРабочегоДня Тогда
				КонецРабочегоДняМинуты = КонецРабочегоДня * МинутВЧасе;
			ИначеЕсли ЧасДатыОкончания >= НачалоРабочегоДня Тогда
				КонецРабочегоДняМинуты = ЧасДатыОкончания * МинутВЧасе + Минута(ДатаОкончания);
			Иначе
				СчитатьВремя = Ложь;
			КонецЕсли;
		Иначе
			КонецРабочегоДняМинуты = КонецРабочегоДня * МинутВЧасе;
		КонецЕсли;
		
		// Получаем разницу в минутах, норма для рабочего - 480(420)
		// Т.к. промежуток с 10 - 19 - 540 минут, проверка на превышение
		// максимального времени.
		Если СчитатьВремя Тогда
			МинутыЗаДень = КонецРабочегоДняМинуты - НачалоДня;
			МинутыЗаДень = ?(МинутыЗаДень > НормаВремени, НормаВремени, МинутыЗаДень);
			НакопленныеМинуты = НакопленныеМинуты + МинутыЗаДень;
		КонецЕсли;
		
		ТекущаяДата_НачалоДня = ТекущаяДата_НачалоДня + СекундВДне;
	КонецЦикла;
	
	Возврат НакопленныеМинуты;
	
КонецФункции

Функция ПолучитьНомерОбъектаБезПрефикса(Знач Ссылка, Знач СтрокаНомер) Экспорт
	
	Если ТипЗнч(Ссылка) = Тип("СправочникСсылка.Проекты")
		ИЛИ ТипЗнч(Ссылка) = Тип("ДокументСсылка.Задача") Тогда	
		НачальныйСимвол = 2;
	Иначе
		НачальныйСимвол = 3;
	КонецЕсли;
	
	Возврат Сред(СтрокаНомер, НачальныйСимвол); 
	
КонецФункции

Функция ПолучитьКоличествоПодчиненныхЗадач(Заявка, Знач Записать = Ложь) Экспорт	
	
	КоличествоПодчиненных = 0;
	
	Запрос = Новый Запрос; 
	
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	КОЛИЧЕСТВО(*) КАК Количество
	|ИЗ
	|	РегистрСведений.СтруктураПодчиненности КАК СтруктураПодчиненности
	|ГДЕ
	|	СтруктураПодчиненности.Родитель = &Заявка";

	Запрос.УстановитьПараметр("Заявка", Заявка);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		КоличествоПодчиненных = Выборка.Количество;
	КонецЕсли;
	
	Если Записать Тогда
		РегистрыСведений.ЗначенияДополнительныхРеквизитовОбъектов.УстановитьЗначениеДополнительногоРеквизита(Заявка, 
			ПланыВидовХарактеристик.ВидыДополнительныхРеквизитов.КоличествоПодчиненныхЗадач, КоличествоПодчиненных);		
	КонецЕсли;
	
	Возврат КоличествоПодчиненных;
	
КонецФункции

Функция ПолучитьМинимальныйСтатусЗаявки(Знач Заявка) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	МинимальныеСтатусыЗаявок.Статус КАК Статус
	|ИЗ
	|	РегистрСведений.МинимальныеСтатусыЗаявок КАК МинимальныеСтатусыЗаявок
	|ГДЕ
	|	МинимальныеСтатусыЗаявок.Заявка = &Заявка";
	
	Запрос.УстановитьПараметр("Заявка", Заявка);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Возврат Выборка.Статус;
					
КонецФункции

// Возвращает ФИО в указанном склонении. В случае ошибки склонения вернет исходный вариант
//
// Параметры:
//  ФИО			 - Строка	 - ФИО в именительном падеже
//  Склонение	 - Число	 - 1 - Именительный, 2 - Родительный, 3 - Дательный, 4 - Винительный, 5 - Творительный, 6 - Предложный
//  Пол			 - Число	 - 0 - авто, 1 - мужской, 2 - женский
// 
// Возвращаемое значение:
//  Строка - склоненное ФИО или исходный вариант в случае ошибки
//
Функция ПросклонятьФИО(Знач ФИО, Знач Склонение, Знач Пол = 0) Экспорт
	
	ИмяМакета = "ОбщийМакет.ВнешняяКомпонентаСклонения";
	ВнешняяКомпонента = ИнициализироватьВнешнююКомпоненту(ИмяМакета, "NameDecl", "AddIn.NameDecl.CNameDecl");
	
	Если ВнешняяКомпонента <> Неопределено Тогда
		Попытка
			Результат = ВнешняяКомпонента.Просклонять(ФИО, Склонение, Пол);
		Исключение
			Результат = ФИО;
		КонецПопытки;
	Иначе
		Результат = ФИО;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Вызывается из подписки на событие УстановкаПрефиксаДокумента
//
// Параметры:
//  Источник			 - ДокументОбъект.Задача, ДокументОбъект.ВнутренниеТрудозатраты,
//							ДокументОбъект.ЗаявкаНаРазработку, ДокументОбъект.ВнутреннееЗадание	 - объект
//  СтандартнаяОбработка - Булево	 - признак стандартной обработки
//  Префикс				 - Строка	 - перфикс документа
//
Процедура ПрефиксДокументаУстановкеНовогоНомера(Источник, СтандартнаяОбработка, Префикс) Экспорт

	МенеджерОбъекта = МенеджерОбъектаПоСсылке(Источник.Ссылка);
	Префикс = МенеджерОбъекта.ПолучитьПрефикс();	
	
КонецПроцедуры

// Позволяет определить, есть ли среди реквизитов объекта реквизит с переданным именем.
//
// Параметры:
//  ИмяРеквизита - Строка - имя реквизита;
//  МетаданныеОбъекта - ОбъектМетаданных - объект, в котором требуется проверить наличие реквизита.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЕстьРеквизитОбъекта(ИмяРеквизита, МетаданныеОбъекта) Экспорт
	
	Возврат НЕ (МетаданныеОбъекта.Реквизиты.Найти(ИмяРеквизита) = Неопределено);
	
КонецФункции

Процедура ЗаполнитьОбъектПервоначальнымиДанными(Объект) Экспорт
	
	МетаданныеОбъекта = Объект.Ссылка.Метаданные();
	
	Если ЕстьРеквизитОбъекта("Дата", МетаданныеОбъекта)
		И ТипЗнч(Объект.Дата) = Тип("Дата") Тогда
		
		Объект.Дата = ТекущаяДатаСеанса();
	КонецЕсли;
	
	Если ЕстьРеквизитОбъекта("Автор", МетаданныеОбъекта) 
		И ТипЗнч(Объект.Автор) = Тип("СправочникСсылка.Пользователи") Тогда
		
		Объект.Автор = ПараметрыСеанса.ТекущийПользователь;
	КонецЕсли;
	
КонецПроцедуры

// Шаблоны HTML для формирования уведомлений
// 
// Возвращаемое значение:
//  Структура - шаблоны HTML-страницы
//  *Страница	 - Строка	 - HTML-код страницы
//  *Строка	 - Строка	 - HTML-код строки таблицы
//
Функция ПолучитьHTMLШаблоны() Экспорт
	
	Шаблоны = Новый Структура;
	
	ШаблонСтраницы = 
	"<html>
	|<head>
	|  <meta http-equiv=""Content-Type"" content=""text/html; charset=UTF-8"">
	|  <style type=""text/css"">
	|    html { overflow: auto; }
	|    body { margin: 10px; font-family: Arial, sans-serif; font-size: 10pt; overflow: auto; position: absolute; top: 0; left: 0; bottom: 0; right: 0; }
	|    div.main { overflow: auto; height: 100%; }
	|    div.presentation { font-size: 11pt; }
	|    div.textPortion { padding-bottom: 16px; }
	|    span.bold { font-weight: bold; }
	|    ol li { color: #B3B3B3; }
	|    ol li div { color: #333333; }
	|    a { text-decoration: none; color: #0066CC; }
	|    a:hover { text-decoration: underline; }
	|    .gray { color: #444; }
	|    .f18 { font-size: 18px; line-height: 18px; }
	|    .f14 { font-size: 14px; line-height: 14px; }
	|    .spacer16 { line-height: 16px; height: 16px; }
	|  </style>
	|</head>
	|<body>
	|  <div class=""main"">
	|%Строки%
	|  </div>
	|</body>
	|</html>";
	
	Шаблоны.Вставить("Страница", ШаблонСтраницы); 
	
	ШаблонСтроки = 
	"<table>
	|	<tr><td class=""f18""><a href=""%1"">%2</a></td></tr>
	|	<tr><td class=""spacer16""></td></tr>
	|</table>";
	
	Шаблоны.Вставить("Строка", ШаблонСтроки);
	
	Возврат Шаблоны;
	
КонецФункции

#КонецОбласти

// Выполнить экспортную процедуру по имени с уровнем привилегий конфигурации.
// При включении профилей безопасности для вызова оператора Выполнить() используется
// переход в безопасный режим с профилем безопасности, используемом для информационной базы
// (если выше по стеку не был установлен другой безопасный режим).
//
// Параметры:
//  ИмяМетода - Строка - имя экспортной процедуры в формате 
//                       <имя объекта>.<имя процедуры>, где <имя объекта> - это
//                       общий модуль или модуль менеджера объекта.
//  Параметры - Массив - параметры передаются в процедуру <ИмяЭкспортнойПроцедуры>
//                       в порядке расположения элементов массива.
// 
Процедура ВыполнитьМетодКонфигурации(Знач ИмяМетода, Знач Параметры = Неопределено) Экспорт
	
	ПараметрыСтрокой = "";
	ПараметрыМетода = Новый Массив;
	
	Если Параметры <> Неопределено И Параметры.Количество() > 0 Тогда
		Для Индекс = 0 По Параметры.ВГраница() Цикл
			ПараметрыМетода.Добавить(СтрШаблон("Параметры[%1]", Индекс));
		КонецЦикла;
		
		ПараметрыСтрокой = СтрСоединить(ПараметрыМетода, ", ");
	КонецЕсли;
	
	Выполнить СтрШаблон("%1(%2)", ИмяМетода, ПараметрыСтрокой);
	
КонецПроцедуры

Процедура ДобавитьДатыИзмененияДляПроекта(Знач Ссылка, Знач ЭтоПроект = Ложь) Экспорт
	
	ТекущаяДата = ТекущаяДатаСеанса();	
	
	// Запись в дополнительные реквизиты
	Проект = НайтиРодительПроект(Ссылка);
	
	// Проверка, нашли проект или нет
	Если ТипЗнч(Проект) = Тип("СправочникСсылка.Проекты") Тогда	
		ОписаниеТипа = Новый ОписаниеТипов("ПланВидовХарактеристикСсылка.ВидыДополнительныхРеквизитов");
		
		ДанныеОбъекта = Новый ТаблицаЗначений;
		ДанныеОбъекта.Колонки.Добавить("ВидРеквизита", ОписаниеТипа);
		ДанныеОбъекта.Колонки.Добавить("Значение", ОбщегоНазначенияКлиентСервер.ОписаниеТипаДата(ЧастиДаты.ДатаВремя));
		
		Если ЭтоПроект Тогда
			НоваяСтрока = ДанныеОбъекта.Добавить();
			НоваяСтрока.ВидРеквизита = ПланыВидовХарактеристик.ВидыДополнительныхРеквизитов.ДатаПоследнегоИзмененияОбъекта;
			НоваяСтрока.Значение = ТекущаяДата;
		КонецЕсли;
		
		ВидРеквизита = ПланыВидовХарактеристик.ВидыДополнительныхРеквизитов.ДатаПоследнегоИзмененияПодчиненныхОбъектов;
		
		НоваяСтрока = ДанныеОбъекта.Добавить();
		НоваяСтрока.ВидРеквизита = ВидРеквизита;
		НоваяСтрока.Значение = ТекущаяДата;
		
		РегистрыСведений.ЗначенияДополнительныхРеквизитовОбъектов.ЗаписатьЗначенияРеквизитов(Проект, ДанныеОбъекта);
	КонецЕсли;
	
КонецПроцедуры

// Рекурсивная функция для поиска родителя - Проект.
//  Базовый случай - нет проекта
//  Возвращает ссылку на высшего родителя
//
// Параметры:
//  Объект	 - Задача/ЗаявкаНаРазработку/Проект - объект, у которого требуется найти проект
// 
// Возвращаемое значение:
//   - ссылка на проект/текущий объект
//
Функция НайтиРодительПроект(Объект)
	
	ПолучаемыеРеквизиты = Новый Структура("Основание", "ОбъектОснование");
	
	Если ТипЗнч(Объект) = Тип("ДокументСсылка.Задача") ИЛИ ТипЗнч(Объект) = Тип("ДокументСсылка.ВнутреннееЗадание") Тогда
		ПолучаемыеРеквизиты.Вставить("Проект", "Проект");
	КонецЕсли;

	СтруктураРеквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Объект, ПолучаемыеРеквизиты); 
	Если СтруктураРеквизиты.Свойство("Проект") И ЗначениеЗаполнено(СтруктураРеквизиты.Проект) Тогда
		Возврат НайтиРодительПроект(СтруктураРеквизиты.Проект);
	ИначеЕсли СтруктураРеквизиты.Свойство("Основание") И ЗначениеЗаполнено(СтруктураРеквизиты.Основание) Тогда
		Возврат НайтиРодительПроект(СтруктураРеквизиты.Основание);
	Иначе
		Возврат Объект;
	КонецЕсли;
		 	
КонецФункции

// Возвращает менеджер объекта по ссылке на объект.
// Ограничение: не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - объект, менеджер которого требуется получить.
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер.
// 
Функция МенеджерОбъектаПоСсылке(Ссылка) Экспорт
	
	ИмяОбъекта = Ссылка.Метаданные().Имя;
	ТипСсылки = ТипЗнч(Ссылка);
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Справочники[ИмяОбъекта];
		
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Документы[ИмяОбъекта];
		
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат БизнесПроцессы[ИмяОбъекта];
		
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовХарактеристик[ИмяОбъекта];
		
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыСчетов[ИмяОбъекта];
		
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовРасчета[ИмяОбъекта];
		
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Задачи[ИмяОбъекта];
		
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыОбмена[ИмяОбъекта];
		
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Перечисления[ИмяОбъекта];
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

// Получает объект ДокументHTML из текста HTML
//
// Параметры:
//  ТекстHTML	 - Строка	 - HTML текст
//  Кодировка	 - Строка	 - текстовое представление кодировки
// 
// Возвращаемое значение:
//  ДокументHTML - созданный документ HTML
//
Функция ПолучитьОбъектДокументHTMLИзТекстаHTML(ТекстHTML, Кодировка = Неопределено) Экспорт
	
	Построитель = Новый ПостроительDOM;
	ЧтениеHTML = Новый ЧтениеHTML;
	
	НовыйТекстHTML = ТекстHTML;
	ПозицияОткрытиеXML = СтрНайти(НовыйТекстHTML, "<?xml");
	
	Если ПозицияОткрытиеXML > 0 Тогда
		ПозицияЗакрытиеXML = СтрНайти(НовыйТекстHTML, "?>");
		
		Если ПозицияЗакрытиеXML > 0 Тогда
			КоличествоСимволов = СтрДлина(НовыйТекстHTML) - ПозицияЗакрытиеXML - 1;
			НовыйТекстHTML = Лев(НовыйТекстHTML, ПозицияОткрытиеXML - 1) + Прав(НовыйТекстHTML, КоличествоСимволов);
		КонецЕсли;
	КонецЕсли;
	
	Если Кодировка = Неопределено Тогда
		ЧтениеHTML.УстановитьСтроку(ТекстHTML);
	Иначе
		ЧтениеHTML.УстановитьСтроку(ТекстHTML, Кодировка);
	КонецЕсли;
	
	Возврат Построитель.Прочитать(ЧтениеHTML);
	
КонецФункции

// Получает текст HTML из объекта ДокументHTML.
//
// Параметры:
//  ДокументHTML  - ДокументHTML - документ, из которого будет извлекаться текст.
//
// Возвращаемое значение:
//   Строка   - текст HTML
//
Функция ПолучитьТекстHTMLИзОбъектаДокументHTML(ДокументHTML) Экспорт
	
	ЗаписьDOM = Новый ЗаписьDOM;
	ЗаписьHTML = Новый ЗаписьHTML;
	ЗаписьHTML.УстановитьСтроку();
	ЗаписьDOM.Записать(ДокументHTML, ЗаписьHTML);
	Возврат ЗаписьHTML.Закрыть();
	
КонецФункции

// Проверяет введенный адрес электронной почты на корректность и
//  возвращает ссылку на справочник Подписчики. В случае если введенного адреса
//  не существует в справочнике, то создается новый элемент и возвращается ссылка на него
//
// Параметры:
//  Почта	 - Строка	 - адрес электронной почты
// 
// Возвращаемое значение:
//  Структура - результат проверки подписчика
//  *Подписчик - СправочникСсылка.Подписчики - ссылка на найденного подписчика
//  *Представление - Строка - представление найденного подписчика
//  *ТекстОшибки - Строка - текст сообщения, если подписчик не найден
//
Функция ПроверитьПодписчикаНаСервере(Почта) Экспорт
	
	Результат = Новый Структура("ТекстОшибки, Подписчик, Представление", "", Справочники.Подписчики.ПустаяСсылка(), "");
	
	РезультатПроверкиДомена = ДоменКорректный(Почта); 
	
	АдресСоответствуетТребованиям = ОбщегоНазначенияКлиентСервер.АдресЭлектроннойПочтыСоответствуетТребованиям(Почта);
	
	Если НЕ АдресСоответствуетТребованиям ИЛИ НЕ РезультатПроверкиДомена.ДоменКорректный Тогда
		
		ДоверенныеДомены = РезультатПроверкиДомена.ДоверенныеДомены;
			
		Если ДоверенныеДомены.Количество() = 0 Тогда
			Результат.ТекстОшибки = "Не удалось выполнить проверку домена, т.к. не указаны доверенные домены в системе";
		Иначе
			Разделитель = СтрШаблон(",%1pochta@", Символы.ПС);
			Результат.ТекстОшибки = СтрШаблон("Введенный адрес электронной почты не соответствует требованиям.
			|Адрес должен иметь вид: 
			|pochta@%1", СтрСоединить(ДоверенныеДомены, Разделитель));
		КонецЕсли;
	
		Возврат Результат;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Пользователи.Ссылка КАК Ссылка,
	|	Пользователи.Наименование КАК Наименование,
	|	0 КАК ПриоритетНаблюдателя
	|ПОМЕСТИТЬ ДанныеПоПользователю
	|ИЗ
	|	Справочник.Пользователи КАК Пользователи
	|ГДЕ
	|	Пользователи.Почта = &Почта
	|	И Пользователи.Почта <> """" 
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	Подписчики.Ссылка,
	|	Подписчики.Наименование,
	|	1
	|ИЗ
	|	Справочник.Подписчики КАК Подписчики
	|ГДЕ
	|	Подписчики.Наименование = &Почта
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	ДанныеПоПользователю.Ссылка КАК Ссылка,
	|	ДанныеПоПользователю.Наименование КАК Наименование,
	|	ДанныеПоПользователю.ПриоритетНаблюдателя КАК ПриоритетНаблюдателя
	|ИЗ
	|	ДанныеПоПользователю КАК ДанныеПоПользователю
	|
	|УПОРЯДОЧИТЬ ПО
	|	ПриоритетНаблюдателя";
	
	Запрос.УстановитьПараметр("Почта", Почта);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		Результат.Подписчик = Выборка.Ссылка;
		Результат.Представление = Выборка.Наименование;
	Иначе
		Подписчик = Справочники.Подписчики.Добавить(Почта);
		Если ЗначениеЗаполнено(Подписчик.ТекстОшибки) Тогда
			Результат.ТекстОшибки = Подписчик.ТекстОшибки;
		Иначе
			Результат.Подписчик = Подписчик.Ссылка;
			Результат.Представление = Почта;
		КонецЕсли;
	КонецЕсли;	
	
	Возврат Результат;
	
КонецФункции

Функция ПроверитьОбъектКопирования(Знач ЭтотОбъект) Экспорт

	Перем РодительскийОбъект;
	
	ЗапретРодительскогоОбъекта = Ложь;		
	Если ЭтотОбъект.Параметры.Свойство("ЗначениеКопирования", РодительскийОбъект) И ЗначениеЗаполнено(РодительскийОбъект) Тогда
		
		СообщениеПриЗапрете = "Для объекта установлен признак ""Ограниченный просмотр"". Копирование невозможно.";
		ЗапретРодительскогоОбъекта = Безопасность.ПроверитьПраваРодительскогоОбъекта(ЭтотОбъект,
			ЭтотОбъект.ИмяФормы, РодительскийОбъект, СообщениеПриЗапрете);
	КонецЕсли;
	
	Возврат ЗапретРодительскогоОбъекта;
	
КонецФункции

// Проверяет домен электронной почты на соответствие доверенным доменам
//
// Параметры:
//  Почта	 - Строка	 - адрес электронной почты
// 
// Возвращаемое значение:
//  Булево - признак, корректный домен или нет
//
Функция ДоменКорректный(Знач Почта) Экспорт
	
	ДоверенныеДомены = ПовторноеИспользованиеВызовСервера.ДоверенныеДомены();
	
	ПозицияРазделителя = СтрНайти(Почта, "@");
	Домен = Сред(Почта, ПозицияРазделителя + 1);
	
	Результат = НЕ (ДоверенныеДомены.Найти(Домен) = Неопределено);

	Возврат Новый Структура("ДоменКорректный, ДоверенныеДомены", Результат, ДоверенныеДомены);
	
КонецФункции	

// Заполняет список выбора переданный параметром значениями из справочника НазначенияЗадач
//
// Параметры:
//  СписокНазначений - СписокЗначений - Список выбора назначений задач
//
Процедура ЗаполнитьСписокНазначений(СписокНазначений) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	НазначенияЗадач.Ссылка КАК Ссылка,
	|	НазначенияЗадач.Наименование КАК Наименование,
	|	НазначенияЗадач.ИмяКартинки КАК ИмяКартинки
	|ИЗ
	|	Справочник.НазначенияЗадач КАК НазначенияЗадач
	|ГДЕ
	|	НазначенияЗадач.ПометкаУдаления = ЛОЖЬ
	|
	|УПОРЯДОЧИТЬ ПО
	|	НазначенияЗадач.Порядок";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Если ЗначениеЗаполнено(Выборка.ИмяКартинки) Тогда
			СписокНазначений.Добавить(Выборка.Ссылка, Выборка.Наименование, , БиблиотекаКартинок[Выборка.ИмяКартинки]);
		Иначе
			СписокНазначений.Добавить(Выборка.Ссылка, Выборка.Наименование);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// СЕРЬЕЗНОСТЬ ОШИБОК

// Заполняет список выбора переданный параметром значениями из справочника СерьезностьОшибок
//
// Параметры:
//  Список - СписокЗначений - Список выбора вариантов серьезности ошибок
//
Процедура ЗаполнитьСписокСерьезностьОшибки(Список) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	СерьезностьОшибок.Ссылка КАК Ссылка,
	|	СерьезностьОшибок.Наименование КАК Наименование,
	|	СерьезностьОшибок.ИмяКартинки КАК ИмяКартинки
	|ИЗ
	|	Справочник.СерьезностьОшибок КАК СерьезностьОшибок
	|ГДЕ
	|	НЕ СерьезностьОшибок.ПометкаУдаления
	|
	|УПОРЯДОЧИТЬ ПО
	|	СерьезностьОшибок.Порядок";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Если ЗначениеЗаполнено(Выборка.ИмяКартинки) Тогда
			Список.Добавить(Выборка.Ссылка, Выборка.Наименование, , БиблиотекаКартинок[Выборка.ИмяКартинки]);
		Иначе
			Список.Добавить(Выборка.Ссылка, Выборка.Наименование);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Устанавливает видимость поля ввода СерьезностьОшибок 
//
// Параметры:
//  Элемент    - ПолеФормы - поле ввода для выбора серьезности ошибки
//  Назначение - СправочникСсылка.НазначенияЗадач - ссылка на элемент справочника
//
Процедура УстановитьВидимостьСерьезности(Элемент, Знач Назначение) Экспорт
	
	Элемент.Видимость = (Назначение = Справочники.НазначенияЗадач.Ошибка);	
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ВИД ПРОЕКТА

// Возвращает вид (родительского) проекта объекта
//
// Параметры:
//  Ссылка	 - СправочникСсылка.Проекты, ДокументСсылка.ЗаявкаНаРазработку,
//				ДокументСсылка.ВнутреннееЗадание, ДокументСсылка.Задача	 - ссылка на объект
// 
// Возвращаемое значение:
//  СправочникСсылка.ВидыПроектов - вид родительского проекта
//
Функция ПолучитьВидРодительскогоПроекта(Знач Ссылка) Экспорт
	
	ТипСсылки = ТипЗнч(Ссылка);
	
	Если ТипСсылки = Тип("СправочникСсылка.Проекты") Тогда
		ИмяРеквизита = "ВидПроекта";
	Иначе
		ИмяРеквизита = "ВидРодительскогоПроекта";
	КонецЕсли;
	
	Возврат ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита);
	
КонецФункции

// Через критерий отбора СтруктураПодчиненности получает ссылки на все подчиненные объекты
//
// Параметры:
//  Ссылка	 - Проект/Задача/Заявка/ВнутреннееЗадание - Родительский объект
//  Массив	 - Массив - подчиненные объекты
//
Функция ПолучитьСсылкиНаВсеПодчиненныеОбъекты(Знач Ссылка) Экспорт
	
	Возврат РегистрыСведений.СтруктураПодчиненности.ПолучитьПодчиненныеОбъектыСИерархией(Ссылка);
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Построитель запроса

// Добавляет элемент отбора в построитель запроса
//
// Параметры:
//  ПостроительЗапроса - ПостроительЗапроса - Объект построитель запроса
//  ИмяПоля		 - Строка - название поля 
//  ВидСравнения - ВидСравненияКомпоновкиДанных - предопределенное значение вида
//  Значение	 - Составной тип - массив, строка, булево, ссылка и т .п. 
//
Процедура ДобавитьЭлементОтбораПостроителяЗапросов(ПостроительЗапроса, Знач ИмяПоля, Знач ВидСравнения, Знач Значение) Экспорт
		
	ЭлементОтбора = ПостроительЗапроса.Отбор.Добавить(ИмяПоля);
	ЭлементОтбора.ВидСравнения  = ВидСравнения;
	ЭлементОтбора.Значение      = Значение;
	ЭлементОтбора.Использование = Истина;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// СКД - система компоновки данных

// Добавляет элемент отбора компоновки данных в настройки компоновки данных
//
// Параметры:
//  НастройкиСКД - НастройкиКомпоновкиДанных - настройки схемы компоновки данных
//  ИмяПоля		 - Строка - название поля 
//  ВидСравнения - ВидСравненияКомпоновкиДанных - предопределенное значение вида
//  Значение	 - Составной тип - массив, строка, булево, ссылка и т .п. 
//
Процедура ДобавитьЭлементОтбораКомпоновкиДанных(НастройкиСКД, Знач ИмяПоля, Знач ВидСравнения, Знач Значение) Экспорт
	
	НовыйЭлементОтбора = НастройкиСКД.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	НовыйЭлементОтбора.ВидСравнения = ВидСравнения;
	НовыйЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
	НовыйЭлементОтбора.ПравоеЗначение = Значение;
	НовыйЭлементОтбора.Использование = Истина;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// СТРУКТУРА ПОДЧИНЕННОСТИ

Процедура ЗагрузитьСтруктуруПодчиненности(Знач Объект, Знач АдресВоВременномХранилище, Знач Дерево) Экспорт	
		
	СтруктураКэша = РегистрыСведений.СтруктураПодчиненности.ПолучитьДанныеСтруктурыПодчиненности(Объект);
	Дерево = СтруктураКэша.Дерево;
	ПоместитьВоВременноеХранилище(СтруктураКэша, АдресВоВременномХранилище);
	 
КонецПроцедуры
